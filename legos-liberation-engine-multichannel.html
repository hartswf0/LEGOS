<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>LEGOS Multi-Channel Engine</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='75' font-size='80'>✦</text></svg>">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    :root {
      --transition: cubic-bezier(0.4, 0, 0.2, 1);
      --column-width: min(100vw, 420px);
    }

    body {
      --bg: #03180c;
      --panel: #052010;
      --panel-dark: #03140d;
      --border: #0c3a23;
      --border-light: #1b6e3e;
      --text: #aef3c1;
      --text-muted: #5ea275;
      --accent: #56ff9f;
      --accent-soft: rgba(86, 255, 159, 0.12);
      --accent-glow: rgba(86, 255, 159, 0.32);
      --danger: #ff5c7c;
      --success: #56ff9f;
      --grid-highlight: rgba(86, 255, 159, 0.08);
      --shadow: rgba(0, 0, 0, 0.45);
      --overlay-backdrop: rgba(4, 20, 12, 0.88);
      font-family: 'Courier New', monospace;
      font-size: clamp(11px, 2.4vw, 13px);
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
      min-height: 100vh;
      min-height: 100dvh;
    }

    body.theme-crt {
      --bg: #03180c;
      --panel: #052010;
      --panel-dark: #03140d;
      --border: #0c3a23;
      --border-light: #1b6e3e;
      --text: #aef3c1;
      --text-muted: #5ea275;
      --accent: #56ff9f;
      --accent-soft: rgba(86, 255, 159, 0.12);
      --accent-glow: rgba(86, 255, 159, 0.32);
      --danger: #ff5c7c;
      --success: #56ff9f;
      --grid-highlight: rgba(86, 255, 159, 0.08);
      --overlay-backdrop: rgba(4, 20, 12, 0.88);
      --shadow: rgba(0, 0, 0, 0.45);
    }

    body.theme-parchment {
      --bg: #f6efdd;
      --panel: #efe4c8;
      --panel-dark: #e4d3b0;
      --border: #cdb181;
      --border-light: #b99158;
      --text: #3b3322;
      --text-muted: #7b6d4d;
      --accent: #d17b24;
      --accent-soft: rgba(209, 123, 36, 0.14);
      --accent-glow: rgba(209, 123, 36, 0.32);
      --danger: #c2463b;
      --success: #2e8f4d;
      --grid-highlight: rgba(209, 123, 36, 0.16);
      --overlay-backdrop: rgba(247, 240, 222, 0.92);
      --shadow: rgba(74, 58, 32, 0.28);
    }

    body.theme-thousand {
      --bg: #050507;
      --panel: rgba(28, 12, 18, 0.92);
      --panel-dark: rgba(18, 8, 12, 0.92);
      --border: #2f121a;
      --border-light: #812934;
      --text: #f6f2ef;
      --text-muted: #d3cdc9;
      --accent: #ff3d4e;
      --accent-soft: rgba(255, 61, 78, 0.18);
      --accent-glow: rgba(255, 61, 78, 0.35);
      --danger: #ff6d7a;
      --success: #f8d66a;
      --grid-highlight: rgba(255, 61, 78, 0.14);
      --overlay-backdrop: rgba(12, 6, 12, 0.88);
      --shadow: rgba(0, 0, 0, 0.6);
    }

    .app-shell {
      position: relative;
      width: 100vw;
      height: 100vh;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    .scroll-container {
      .channel-scroller {
        display: flex;
        overflow-x: auto;
        overflow-y: hidden;
        gap: 0;
        scroll-snap-type: x mandatory;
        scroll-behavior: smooth;
        -webkit-overflow-scrolling: touch;
        position: relative;
      }
      
      .channel-scroller::-webkit-scrollbar {
        height: 6px;
      }
      
      .channel-scroller::-webkit-scrollbar-track {
        background: var(--panel-dark);
      }
      
      .channel-scroller::-webkit-scrollbar-thumb {
        background: var(--accent);
        border-radius: 3px;
      }
      flex: 1;
      display: flex;
      overflow-x: auto;
      overflow-y: hidden;
      scroll-snap-type: x mandatory;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      background: var(--bg);
      gap: 1px;
      border-top: 1px solid var(--border);
    }

    .channel-column {
      position: relative;
      flex: 0 0 var(--column-width);
      max-width: var(--column-width);
      height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      height: calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      background: var(--panel-dark);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      scroll-snap-align: start;
      transition: transform 0.45s var(--transition), opacity 0.45s var(--transition);
      padding: 0 16px;
      box-sizing: border-box;
    }

    .channel-column.collapsed {
      flex: 0 0 52px;
      max-width: 52px;
      min-width: 52px;
      border-right: 1px solid var(--border);
      box-shadow: 2px 0 8px var(--shadow);
      overflow: visible;
      position: relative;
    }

    .channel-head {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: stretch;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
      transition: opacity 0.3s var(--transition);
    }

    .channel-column.collapsed .channel-head,
    .channel-column.collapsed .channel-body {
      opacity: 0;
      pointer-events: none;
    }

    .channel-meta {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      text-align: center;
    }

    .channel-name {
      display: none !important;
    }

    .channel-lineage {
      font-size: 7.5px;
      color: var(--text-muted);
      letter-spacing: 0.18em;
      text-transform: uppercase;
    }

    .channel-actions {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .channel-head select,
    .channel-head button {
      touch-action: manipulation;
    }

    .channel-number-rail {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      justify-content: flex-start;
      width: 32px;
      flex-shrink: 0;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 12px 0;
      position: sticky;
      top: 0;
      max-height: 100%;
      z-index: 2;
    }
    
    .channel-number-rail::-webkit-scrollbar {
      width: 4px;
    }
    
    .channel-number-rail::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 2px;
    }

    .channel-number {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid var(--border);
      background: var(--panel-dark);
      color: var(--text-muted);
      font-size: 9px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      flex-shrink: 0;
    }

    .channel-number.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      box-shadow: 0 0 12px var(--accent-glow);
    }

    .channel-number.add {
      border-style: dashed;
    }

    select.channel-scenario {
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 9px;
      letter-spacing: 0.18em;
      padding: 6px 10px;
      border-radius: 3px;
      cursor: pointer;
      position: relative;
      z-index: 100;
    }

    .channel-btn {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.25s var(--transition);
    }

    .channel-btn:active {
      transform: scale(0.9);
      color: var(--text);
      background: var(--panel);
    }

    .channel-head {
      margin-top: 0;
      border-radius: 0;
    }

    .channel-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      margin-bottom: clamp(44px, 10vw, 64px);
      gap: 8px;
    }

    .channel-column.collapsed .channel-body {
      margin-bottom: 0;
    }
    
    .channel-column:not([data-channel-id]) {
      opacity: 0.5;
      filter: grayscale(0.3);
    }
    
    .channel-column.inactive {
      opacity: 0.4;
      filter: saturate(0.5);
      transition: opacity 0.3s var(--transition), filter 0.3s var(--transition);
    }
    
    .channel-column.channel-active {
      box-shadow: 0 0 0 3px var(--accent), 0 0 30px var(--accent-glow);
      position: relative;
      z-index: 10;
      opacity: 1 !important;
    }
    
    .channel-column.channel-active::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border: 3px solid var(--accent);
      border-radius: 8px;
      pointer-events: none;
      animation: pulse-border 1.5s ease-in-out infinite;
      opacity: 0.9;
    }
    
    @keyframes pulse-border {
      0%, 100% { opacity: 0.7; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.005); }
    }
    
    @keyframes sparkle {
      0%, 100% { opacity: 1; text-shadow: 0 0 8px currentColor; }
      50% { opacity: 0.6; text-shadow: 0 0 16px currentColor, 0 0 24px currentColor; }
    }
    
    /* Channel color theming */
    .channel-column .channel-btn:hover {
      background: var(--channel-color, var(--accent)) !important;
      color: var(--bg) !important;
      border-color: var(--channel-color, var(--accent)) !important;
    }
    
    .channel-column .send-btn {
      background: var(--channel-color, var(--accent));
      border-color: var(--channel-color, var(--accent));
    }
    
    .channel-column .grid-cell.occupied {
      border-color: var(--channel-color, var(--accent));
    }
    
    .channel-column .message-dot {
      color: var(--channel-color, var(--accent));
      border-color: var(--channel-color, var(--accent));
    }
    
    .channel-column .channel-head {
      border-bottom-color: var(--channel-color, var(--border));
    }
    
    .channel-column .channel-footer {
      border-top-color: var(--channel-color, var(--border));
    }
    
    .channel-column .channel-scenario:hover,
    .channel-column .channel-scenario:focus {
      border-color: var(--channel-color, var(--accent));
    }

    .overlay-section {
      padding: 12px 0;
      border-bottom: 1px solid var(--border);
    }
    
    .overlay-section.clickable {
      cursor: pointer;
      transition: all 0.2s var(--transition);
      padding: 12px 8px;
      margin: 0 -8px;
      border-radius: 4px;
    }
    
    .overlay-section.clickable:hover {
      background: var(--panel-dark);
      border-color: var(--accent);
    }
    
    .overlay-section.clickable .overlay-value {
      position: relative;
    }
    
    .overlay-section.clickable:hover .overlay-value::after {
      content: '→ Send to chat';
      position: absolute;
      right: 0;
      top: 0;
      font-size: 8px;
      color: var(--accent);
      opacity: 0.7;
      letter-spacing: 0.1em;
    }

    .resize-bar {
      height: 6px;
      background: var(--border);
      cursor: row-resize;
      flex-shrink: 0;
      transition: background 0.2s;
      position: relative;
      touch-action: none;
    }
    
    .resize-bar:hover,
    .resize-bar:active {
      background: var(--accent);
    }
    
    .resize-bar::before {
      content: '';
      position: absolute;
      top: -12px;
      bottom: -12px;
      left: 0;
      right: 0;
    }
    
    .grid-section {
      flex: 0 0 50vh;
      height: 50vh;
      display: flex;
      flex-direction: column;
      min-width: 0;
      position: relative;
    }

    .grid-section.collapsed {
      max-height: 0;
      padding: 0;
      overflow: hidden;
      opacity: 0;
      border: none;
    }

    .grid-area {
      display: flex;
      align-items: stretch;
      gap: 10px;
    }

    .grid-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .grid-title {
      font-size: 8px;
      letter-spacing: 0.2em;
      color: var(--text-muted);
    }

    .grid-toggle {
      font-size: 11px;
      cursor: pointer;
      color: var(--text-muted);
    }

    .grid-wrapper {
      border: 1px solid var(--border);
      background: var(--panel);
      padding: 8px;
      border-radius: 4px;
      transition: max-height 0.3s var(--transition), opacity 0.3s var(--transition);
      flex: 1;
      display: flex;
    }

    .grid-wrapper.collapsed {
      max-height: 0;
      opacity: 0;
      padding: 0;
      overflow: hidden;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(9, 1fr);
      gap: 2px;
      aspect-ratio: 1;
      width: 100%;
      height: 100%;
      max-width: min(100%, calc(50vh - 80px));
      max-height: min(100%, calc(50vh - 80px));
    }

    .grid-cell {
      position: relative;
      background: var(--panel);
      border: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(12px, 2.5vw, 18px);
      font-weight: 700;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.3s var(--transition);
    }

    .grid-cell:hover {
      border-color: var(--accent);
      transform: scale(1.05);
      z-index: 10;
      box-shadow: 0 0 12px var(--accent-soft);
    }

    .grid-cell.resonance-field::after {
      content: '';
      position: absolute;
      inset: -1px;
      background: radial-gradient(circle, var(--accent-soft) 0%, transparent 70%);
      opacity: 0;
      animation: resonancePulse 2s ease-in-out infinite;
      pointer-events: none;
      z-index: 1;
    }

    .grid-cell.loading {
      animation: cellularAutomata 0.8s ease-in-out infinite;
      border-color: var(--accent);
    }
    
    @keyframes cellularAutomata {
      0% {
        background: var(--panel);
        box-shadow: inset 0 0 8px transparent;
      }
      25% {
        background: linear-gradient(135deg, var(--panel) 0%, var(--accent-soft) 50%, var(--panel) 100%);
        box-shadow: inset 0 0 12px var(--accent-soft);
      }
      50% {
        background: var(--accent-soft);
        box-shadow: inset 0 0 16px var(--accent-glow);
      }
      75% {
        background: linear-gradient(225deg, var(--panel) 0%, var(--accent-soft) 50%, var(--panel) 100%);
        box-shadow: inset 0 0 12px var(--accent-soft);
      }
      100% {
        background: var(--panel);
        box-shadow: inset 0 0 8px transparent;
      }
    }

    .grid-cell.occupied {
      color: var(--text);
      border-color: var(--accent);
      background: linear-gradient(135deg, var(--grid-highlight) 0%, var(--panel) 100%);
      box-shadow: 0 0 0 1px var(--accent-soft) inset, 0 2px 4px rgba(0,0,0,0.2);
      font-weight: 900;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .grid-cell.occupied[data-cell-type="Entity"] {
      animation: entityPulse 3s ease-in-out infinite;
    }

    .grid-cell.occupied[data-cell-type="Goal"] {
      animation: goalBeacon 2.5s ease-in-out infinite;
    }

    @keyframes entityPulse {
      0%, 100% { box-shadow: 0 0 0 1px var(--accent-soft) inset, 0 2px 4px rgba(0,0,0,0.2), 0 0 8px var(--accent-soft); }
      50% { box-shadow: 0 0 0 1px var(--accent-soft) inset, 0 2px 4px rgba(0,0,0,0.2), 0 0 16px var(--accent-glow); }
    }

    @keyframes goalBeacon {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.03); opacity: 0.95; }
    }
    
    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes rippleOut {
      0% {
        box-shadow: 0 0 0 0 var(--accent),
                    0 0 0 0 var(--accent-soft),
                    inset 0 0 20px var(--accent-glow);
        transform: scale(1);
      }
      50% {
        box-shadow: 0 0 0 8px transparent,
                    0 0 0 16px transparent,
                    inset 0 0 30px var(--accent-glow);
        transform: scale(1.1);
      }
      100% {
        box-shadow: 0 0 0 0 transparent,
                    0 0 0 0 transparent,
                    inset 0 0 0 transparent;
        transform: scale(1);
      }
    }
    
    .grid-cell.ripple {
      animation: rippleOut 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    .name-flash {
      position: absolute;
      font-size: 11px;
      font-weight: 900;
      letter-spacing: 0.2em;
      color: var(--accent);
      text-shadow: 0 0 15px var(--accent-glow), 0 0 30px var(--accent-glow);
      opacity: 0;
      animation: nameFlashSmooth 4s ease-in-out forwards;
      pointer-events: none;
      z-index: 1000;
      white-space: nowrap;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.95);
      border-radius: 4px;
      border: 2px solid currentColor;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.9);
    }
    
    .name-flash.new {
      color: #4ade80;
      text-shadow: 0 0 15px #4ade80, 0 0 30px #4ade80;
      border-color: #4ade80;
    }
    
    .name-flash.moved {
      color: #60a5fa;
      text-shadow: 0 0 15px #60a5fa, 0 0 30px #60a5fa;
      border-color: #60a5fa;
    }
    
    .name-flash.disappeared {
      color: #f87171;
      text-shadow: 0 0 15px #f87171, 0 0 30px #f87171;
      border-color: #f87171;
    }
    
    @keyframes nameFlashSmooth {
      0% {
        opacity: 0;
        transform: scale(0.8) translateY(-10px);
      }
      15% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
      85% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
      100% {
        opacity: 0;
        transform: scale(0.9) translateY(5px);
      }
    }
    
    .grid-cell.composing-active::before {
      content: attr(data-compose-letter);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      font-weight: 900;
      color: var(--accent);
      text-shadow: 0 0 12px var(--accent-glow);
      animation: letterDance 0.6s ease-in-out infinite;
      z-index: 0;
      opacity: 0.7;
    }
    
    @keyframes letterDance {
      0%, 100% {
        transform: translate(-50%, -50%) rotate(-5deg) scale(1);
      }
      50% {
        transform: translate(-50%, -50%) rotate(5deg) scale(1.15);
      }
    }

    .grid-label {
      position: absolute;
      bottom: 2px;
      left: 2px;
      right: 2px;
      font-size: 6px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      padding: 1px 2px;
      border-radius: 2px;
      backdrop-filter: blur(2px);
      text-shadow: none;
      font-weight: 700;
      line-height: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: calc(100% - 4px);
    }
    
    .grid-label.dark-text {
      color: rgba(0, 0, 0, 0.85);
      background: rgba(255, 255, 255, 0.7);
    }
    
    .grid-label.light-text {
      color: rgba(255, 255, 255, 0.95);
      background: rgba(0, 0, 0, 0.6);
    }
    
    .grid-cell:hover .grid-label {
      font-size: 8px;
      padding: 2px 4px;
      opacity: 1;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
    }

    .grid-collapse-btn {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text-muted);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .grid-collapse-btn:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }

    .chat-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--panel);
      min-height: 0;
      overflow: hidden;
      transition: flex 0.3s var(--transition);
      position: relative;
      padding-top: 12px;
      gap: 12px;
    }

    .channel-body.grid-collapsed .grid-section.collapsed ~ .chat-section {
      flex: 2;
    }

    .message-list {
      flex: 1;
      overflow-y: auto;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
    }

    .message {
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: var(--panel);
      border: 1px solid var(--border);
      padding: 12px 14px;
      border-radius: 4px;
      position: relative;
      transition: transform 0.2s var(--transition);
    }

    .message.active {
      border-color: var(--accent);
      box-shadow: 0 0 12px var(--accent-soft);
    }

    .message.user {
      border-left: 2px solid var(--success);
      cursor: pointer;
    }

    .message.assistant {
      border-left: 2px solid var(--accent);
      cursor: pointer;
    }

    .message.system {
      border-left: 2px solid var(--text-muted);
      background: var(--panel-dark);
      opacity: 0.85;
    }

    .message.collapsed .message-body {
      max-height: 0;
      opacity: 0.2;
      overflow: hidden;
    }
    
    .message.collapsed .tetrad-chips-inline {
      display: flex !important;
      opacity: 1 !important;
      max-height: none !important;
    }

    .message.collapsed .message-preview {
      opacity: 1;
    }

    .message-header {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 8px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .ring-indicator {
      font-size: 12px;
      filter: drop-shadow(0 0 8px currentColor);
      animation: ringPulse 2s ease-in-out infinite;
      cursor: help;
    }

    @keyframes ringPulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    .message-color-dot {
      font-size: 10px;
      line-height: 1;
      filter: drop-shadow(0 0 6px currentColor);
      flex-shrink: 0;
      font-weight: bold;
    }

    .message-color-dot.parent-dot {
      opacity: 0.6;
      font-size: 8px;
      margin-right: -4px;
    }

    .message-dot.forked-dot {
      position: relative;
    }

    .message-dot.forked-dot::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border-radius: 50%;
      border: 2px solid currentColor;
      pointer-events: none;
    }

    .message-preview {
      font-size: 9px;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      display: none;
    }

    .message.collapsed .message-preview {
      display: block;
    }

    .message-body {
      color: var(--text);
      line-height: 1.6;
      white-space: pre-wrap;
      transition: opacity 0.2s var(--transition);
    }

    .message-actions {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--panel);
      border: 1px solid var(--accent);
      border-radius: 6px;
      display: none;
      flex-direction: column;
      min-width: 240px;
      max-width: 90vw;
      z-index: 200;
      box-shadow: 0 12px 48px var(--shadow);
    }

    .message-actions.active {
      display: flex;
    }

    .message-actions::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: -1;
      backdrop-filter: blur(6px);
    }

    .message-action-close {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--panel-dark);
      color: var(--text-muted);
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s var(--transition);
      z-index: 10;
    }

    .message-action-close:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      transform: rotate(90deg);
    }

    .message-action {
      padding: 14px 18px;
      font-size: 10px;
      letter-spacing: 0.2em;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: all 0.2s var(--transition);
    }

    .message-action.disabled {
      opacity: 0.55;
      cursor: default;
      pointer-events: none;
      font-style: italic;
      color: var(--text-muted);
    }

    .message-action:last-child {
      border-bottom: none;
    }

    .message-action:active {
      background: var(--panel-dark);
      color: var(--text);
    }

    .message.fork-origin {
      border-style: dashed;
      border-color: var(--accent);
    }

    .input-section {
      padding: 12px 0 0 0;
      border-top: 1px solid var(--border);
      background: var(--panel);
      flex-shrink: 0;
      margin-top: 8px;
      position: sticky;
      bottom: 0;
      z-index: 100;
    }
    
    /* Mobile keyboard compensation */
    @supports (height: 100dvh) {
      .channel-column {
        height: 100dvh;
      }
    }

    .input-wrapper {
      display: flex;
      gap: 8px;
      align-items: stretch;
    }

    textarea.message-input {
      flex: 1;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 4px;
      font-size: 10px;
      line-height: 1.4;
      resize: none;
      min-height: 36px;
      max-height: 80px;
      transition: all 0.3s var(--transition);
    }
    
    textarea.message-input:focus {
      outline: none;
      border-color: var(--accent);
      background: var(--panel);
      box-shadow: 0 0 12px var(--accent-glow);
    }
    
    .channel-column.channel-active textarea.message-input {
      border-color: var(--accent);
      box-shadow: 0 0 8px rgba(86, 255, 159, 0.2);
    }

    .footer-btn {
      transition: all 0.2s var(--transition);
    }
    
    .footer-btn:hover {
      background: var(--accent) !important;
      color: var(--bg) !important;
      border-color: var(--accent) !important;
      transform: scale(1.05);
    }
    
    .footer-btn:active {
      transform: scale(0.95);
    }
    
    .tetrad-footer-btn {
      font-size: 16px;
    }

    textarea.message-input:focus {
      outline: none;
      border-color: var(--border-light);
    }

    .send-btn {
      padding: 12px 18px;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 9px;
      letter-spacing: 0.2em;
      cursor: pointer;
      transition: all 0.25s var(--transition);
      border-radius: 4px;
    }

    .send-btn:disabled {
      opacity: 0.35;
      cursor: not-allowed;
    }

    .send-btn:active:not(:disabled) {
      transform: scale(0.95);
      color: var(--text);
    }

    .tetrad-chip {
      padding: 12px 16px;
      background: var(--panel);
      border: 3px solid var(--border);
      border-radius: 8px;
      font-size: 9px;
      letter-spacing: 0.2em;
      color: var(--text);
      cursor: pointer;
      transition: all 0.15s var(--transition);
      text-align: center;
      font-weight: bold;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      text-transform: uppercase;
      white-space: nowrap;
      min-height: 52px;
      box-shadow: 0 2px 0 var(--border), inset 0 1px 0 rgba(255,255,255,0.1);
    }

    .tetrad-chip-text {
      flex: 1;
      text-align: center;
    }

    .tetrad-chip::before {
      content: '▲';
      font-size: 18px;
      color: var(--accent);
      transition: all 0.3s var(--transition);
      position: absolute;
      left: 12px;
    }

    .tetrad-chip.enhance::before { content: '▲'; }
    .tetrad-chip.reverse::before { content: '⇄'; }
    .tetrad-chip.retrieve::before { content: '↺'; }
    .tetrad-chip.obsolesce::before { content: '▼'; }

    .tetrad-chip:hover {
      border-color: var(--accent);
      background: var(--accent);
      color: var(--bg);
      transform: scale(1.02);
    }

    .tetrad-chip:hover::before {
      color: var(--bg);
      transform: scale(1.15);
      filter: drop-shadow(0 0 12px var(--accent-glow));
    }

    .tetrad-chip:active {
      transform: scale(0.95) translateY(2px);
      box-shadow: 0 0 0 var(--border), inset 0 1px 0 rgba(255,255,255,0.1);
    }

    .tetrad-refresh-btn {
      padding: 6px 12px;
      font-size: 8px;
      letter-spacing: 0.18em;
      background: var(--panel);
      color: var(--text-muted);
      border: 1px solid var(--border);
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.2s var(--transition);
    }

    .tetrad-refresh-btn:active:not(:disabled) {
      transform: scale(0.96);
      color: var(--text);
      border-color: var(--accent);
    }

    .tetrad-refresh-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .corner-btn {
      position: fixed;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 12;
      box-shadow: 0 8px 24px var(--shadow);
      transition: transform 0.2s var(--transition), box-shadow 0.2s var(--transition);
    }

    .corner-btn:active {
      transform: scale(0.92);
      box-shadow: 0 4px 16px var(--accent-soft);
      color: var(--accent);
      border-color: var(--accent);
    }

    .corner-btn.top-left {
      top: calc(16px + env(safe-area-inset-top));
      left: calc(16px + env(safe-area-inset-left));
    }

    .corner-btn.top-right {
      top: calc(16px + env(safe-area-inset-top));
      right: calc(16px + env(safe-area-inset-right));
    }

    .corner-btn.bottom-left {
      bottom: calc(16px + env(safe-area-inset-bottom));
      left: calc(16px + env(safe-area-inset-left));
    }

    .corner-btn.bottom-right {
      bottom: calc(16px + env(safe-area-inset-bottom));
      right: calc(16px + env(safe-area-inset-right));
    }

    .corner-menu {
      position: fixed;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 12px 32px var(--shadow);
      display: none;
      flex-direction: column;
      min-width: 160px;
      z-index: 14;
    }

    .corner-menu.visible {
      display: flex;
    }

    .corner-menu button {
      background: transparent;
      border: none;
      color: var(--text-muted);
      padding: 12px 16px;
      font-size: 9px;
      letter-spacing: 0.18em;
      text-align: left;
      cursor: pointer;
      transition: background 0.2s var(--transition), color 0.2s var(--transition);
    }

    .corner-menu button:active {
      background: var(--panel-dark);
      color: var(--text);
    }


    .ring-bar {
      display: none;
    }
    
    .global-footer {
      position: fixed;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      height: auto;
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 6px 12px;
      z-index: 100;
      gap: 6px;
    }
    
    .footer-control-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 2px solid var(--border);
      background: var(--panel-dark);
      color: var(--text-muted);
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s var(--transition);
    }
    
    .footer-control-btn:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      transform: scale(1.05);
    }
    
    .footer-control-btn.add {
      border-style: dashed;
      font-size: 24px;
      font-weight: 300;
    }
    
    .global-scenario-select {
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--text-muted);
      padding: 5px 8px;
      border-radius: 4px;
      font-size: 9px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      min-width: 110px;
      max-width: 130px;
    }
    
    .global-scenario-select:hover,
    .global-scenario-select:focus {
      border-color: var(--accent);
      background: var(--panel);
      outline: none;
    }
    
    .footer-tetrad-btn {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text-muted);
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s var(--transition);
    }
    
    .footer-tetrad-btn:hover {
      background: var(--accent);
      color: var(--bg);
      transform: scale(1.08);
    }
    
    .scroll-container {
      padding-bottom: 0;
    }

    .ring-bar::-webkit-scrollbar {
      display: none;
    }

    .ring-entry {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid currentColor;
      background: var(--panel-dark);
      cursor: pointer;
      transition: all 0.3s var(--transition);
      position: relative;
      flex-shrink: 0;
      filter: brightness(1.2) saturate(1.4);
    }

    .ring-entry:hover {
      transform: scale(1.3);
      filter: brightness(1.5) saturate(1.8);
    }

    .ring-entry.active {
      transform: scale(1.25);
      box-shadow: 0 0 12px currentColor;
    }

    .ring-entry.mainline {
      width: 18px;
      height: 18px;
      border-width: 3px;
      box-shadow: 0 0 16px currentColor, inset 0 0 8px currentColor;
      animation: mainlinePulse 3s ease-in-out infinite;
    }

    @keyframes mainlinePulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; box-shadow: 0 0 24px currentColor, inset 0 0 12px currentColor; }
    }

    .chat-stream {
      display: flex;
      gap: 8px;
      padding: 8px 0 16px 0;
      overflow-y: auto;
      overflow-x: hidden;
      min-height: 0;
    }

    .message-dot-rail {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding-top: 12px;
      position: sticky;
      top: calc(80px + env(safe-area-inset-top));
      z-index: 2;
      align-items: center;
      width: 32px;
      flex-shrink: 0;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
      overflow-x: hidden;
    }
    
    .message-dot-rail::-webkit-scrollbar {
      width: 4px;
    }
    
    .message-dot-rail::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 2px;
    }

    .message-dot {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid currentColor;
      background: var(--panel-dark);
      cursor: pointer;
      color: var(--text);
      font-size: 8px;
      flex-shrink: 0;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      transition: all 0.3s var(--transition);
    }

    .message-dot.assistant {
      box-shadow: 0 0 12px currentColor;
      filter: brightness(1.3) saturate(1.5);
    }

    .message-dot.user {
      width: 20px;
      height: 20px;
      box-shadow: 0 0 10px currentColor;
      filter: brightness(1.4) saturate(1.6);
    }

    .message-dot.system {
      width: 18px;
      height: 18px;
      opacity: 0.75;
      box-shadow: 0 0 6px currentColor;
      filter: brightness(0.8);
    }

    .message-dot.fork-origin {
      border-width: 2px;
      box-shadow: 0 0 10px var(--accent-glow);
    }

    .message-dot.active {
      transform: scale(1.15);
      box-shadow: 0 0 8px var(--accent-glow);
    }

    .send-btn {
      font-size: 18px;
      letter-spacing: 0;
      border-radius: 6px;
      min-width: 44px;
      padding: 0 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .grid-cell.occupied:hover {
      transform: scale(1.08);
      box-shadow: 0 0 20px var(--accent-glow);
      z-index: 5;
    }
    
    .grid-cell.occupied::after {
      content: attr(data-full-name);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.95);
      color: var(--accent);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 700;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 100;
      border: 1px solid var(--accent);
      box-shadow: 0 4px 12px rgba(0,0,0,0.8);
    }
    
    .grid-cell.occupied:hover::after {
      opacity: 1;
    }

    .tetrad-chip:hover {
      border-color: var(--accent);
      color: var(--text);
    }

    .snapshot-overlay-list {
      max-height: 240px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 16px 0;
    }

    .ring-context-block {
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--panel-dark);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 260px;
    }

    .ring-context-controls {
      display: flex;
      gap: 6px;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .ring-context-btn {
      flex: 1 1 auto;
      text-align: center;
      font-size: 8px;
      letter-spacing: 0.16em;
      padding: 6px 8px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 3px;
      transition: all 0.2s var(--transition);
    }

    .ring-context-btn.active {
      border-color: var(--accent);
      color: var(--accent);
      box-shadow: 0 0 10px var(--accent-soft);
    }

    .ring-context-window {
      font-size: 8px;
      letter-spacing: 0.18em;
      color: var(--text-muted);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 3px;
      padding: 10px;
      overflow-y: auto;
      white-space: pre-wrap;
      max-height: 180px;
    }

    .snapshot-overlay-item {
      padding: 10px 12px;
      border: 1px solid var(--border);
      background: var(--panel-dark);
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .snapshot-overlay-meta {
      display: flex;
      justify-content: space-between;
      font-size: 8px;
      letter-spacing: 0.18em;
      color: var(--text-muted);
    }

    .snapshot-overlay-actions {
      display: flex;
      gap: 8px;
    }

    .snapshot-overlay-actions button {
      flex: 1;
    }

    .overlay {
      position: fixed;
      inset: 0;
      background: var(--overlay-backdrop);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
      padding: 24px;
      backdrop-filter: blur(6px);
    }

    .overlay.active {
      display: flex;
    }

    .overlay-card {
      background: var(--panel);
      border: 1px solid var(--border);
      padding: 24px;
      border-radius: 6px;
      width: min(420px, 92vw);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .overlay-title {
      font-size: 9px;
      letter-spacing: 0.24em;
      color: var(--text);
    }

    .overlay-sub {
      font-size: 8px;
      letter-spacing: 0.16em;
      color: var(--text-muted);
    }

    .overlay-input {
      width: 100%;
      border: 1px solid var(--border);
      background: var(--panel-dark);
      color: var(--text);
      padding: 12px 14px;
      font-size: 10px;
      border-radius: 4px;
    }

    .overlay-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .primary-btn {
      padding: 10px 16px;
      border: 1px solid var(--accent);
      background: transparent;
      color: var(--accent);
      letter-spacing: 0.18em;
      cursor: pointer;
      font-size: 9px;
      border-radius: 4px;
    }

    .primary-btn:active:not(:disabled) {
      transform: scale(0.96);
      background: var(--accent-soft);
    }

    .primary-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    
    .tetrad-intervention-btn.glow-active {
      background: var(--accent);
      color: var(--bg);
      box-shadow: 0 0 20px var(--accent-glow), 0 0 40px var(--accent-glow);
      animation: pulse-glow 2s ease-in-out infinite;
    }
    
    .tetrad-intervention-btn.glow-processing {
      background: #60a5fa;
      color: var(--bg);
      box-shadow: 0 0 20px #60a5fa, 0 0 40px #60a5fa;
      animation: pulse-glow 1s ease-in-out infinite;
    }
    
    .tetrad-intervention-btn.glow-success {
      background: #4ade80;
      color: var(--bg);
      box-shadow: 0 0 20px #4ade80;
    }
    
    @keyframes pulse-glow {
      0%, 100% {
        box-shadow: 0 0 15px currentColor, 0 0 30px currentColor;
      }
      50% {
        box-shadow: 0 0 25px currentColor, 0 0 50px currentColor;
      }
    }

    .secondary-btn {
      padding: 10px 16px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text-muted);
      letter-spacing: 0.18em;
      cursor: pointer;
      font-size: 9px;
      border-radius: 4px;
    }

    .grid-area {
      flex: 1;
      overflow: hidden;
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .cell-overlay-content,
    .perspective-overlay-content {
      max-width: 420px;
      width: 92vw;
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .overlay-section {
      display: flex;
      flex-direction: column;
      gap: 6px;
      border: 1px solid var(--border);
      padding: 12px;
      border-radius: 4px;
      background: var(--panel-dark);
    }

    .overlay-label {
      font-size: 8px;
      letter-spacing: 0.16em;
      color: var(--text-muted);
    }

    .overlay-value {
      font-size: 10px;
      line-height: 1.6;
      color: var(--text);
    }

    .overlay-action-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .overlay-action-row button {
      flex: 1 1 auto;
    }

    .close-overlay {
      align-self: flex-end;
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 20px;
      cursor: pointer;
    }

    @media (hover: hover) {
      .message.assistant:hover {
        transform: translateX(4px);
      }

      .grid-cell:hover {
        border-color: var(--border-light);
        transform: scale(1.03);
      }

      .tetrad-chip:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 18px var(--accent-soft);
      }
    }

    ::-webkit-scrollbar {
      width: 4px;
      height: 4px;
    }
    ::-webkit-scrollbar-track {
      background: var(--panel-dark);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    
    .channel-column.composing::after {
      content: 'COMPOSING';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      letter-spacing: 0.32em;
      color: var(--accent);
      animation: pulse 1.2s ease-in-out infinite;
      pointer-events: none;
      z-index: 50;
      text-shadow: 0 0 12px var(--accent-glow);
    }

    .message.reveal {
      animation: reveal 0.6s var(--transition) forwards;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.4; transform: translate(-50%, -50%) scale(0.98); }
      50% { opacity: 1; transform: translate(-50%, -50%) scale(1.02); }
    }

    @keyframes reveal {
      0% { opacity: 0; transform: translateY(12px); }
      100% { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <div class="ring-bar" id="ringBar"></div>
    <div class="scroll-container" id="channelScroller"></div>
    <div class="global-footer" id="globalFooter">
      <select class="global-scenario-select" id="globalScenarioSelect"></select>
      <button class="footer-tetrad-btn" id="globalTetradBtn" title="Set Entity Perspective">✦</button>
    </div>
  </div>

  <div class="overlay" id="keyOverlay">
    <div class="overlay-card">
      <div class="overlay-title">STORE OPENAI KEY</div>
      <div class="overlay-sub">Key persists locally as legos/multi-channel key.</div>
      <input type="password" class="overlay-input" id="keyInput" placeholder="sk-...">
      <div class="overlay-sub" id="keyStatus">Key not stored.</div>
      <div class="overlay-actions">
        <button class="secondary-btn" data-close="keyOverlay">CANCEL</button>
        <button class="primary-btn" id="keySaveBtn">SAVE</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="exportOverlay">
    <div class="overlay-card">
      <div class="overlay-title">EXPORT STATE</div>
      <div class="overlay-sub">Download full multi-channel session as JSON.</div>
      <div class="overlay-actions">
        <button class="secondary-btn" data-close="exportOverlay">CLOSE</button>
        <button class="primary-btn" id="confirmExport">EXPORT JSON</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="cellOverlay">
    <div class="cell-overlay-content" id="cellOverlayContent">
      <button class="close-overlay" data-close="cellOverlay">×</button>
    </div>
  </div>

  <div class="overlay" id="snapshotOverlay">
    <div class="overlay-card">
      <div class="overlay-title">SNAPSHOTS</div>
      <div class="overlay-sub" id="snapshotStatus"></div>
      <div class="snapshot-overlay-list" id="snapshotOverlayList"></div>
      <div class="overlay-actions">
        <button class="secondary-btn" data-close="snapshotOverlay">CLOSE</button>
        <button class="primary-btn" id="snapshotCreateBtn">CREATE</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="ringOverlay">
    <div class="overlay-card">
      <div class="overlay-title">RING MEMORY</div>
      <div class="overlay-sub" id="ringStatus"></div>
      <div class="ring-context-block">
        <div class="ring-context-controls">
          <button class="ring-context-btn" id="ringModeAll" data-mode="all">ALL STREAM</button>
          <button class="ring-context-btn" id="ringModeAnchor" data-mode="anchor">ANCHOR CHANNEL</button>
          <button class="ring-context-btn" id="ringModeMain" data-mode="mainline">MAINLINE</button>
        </div>
        <div class="ring-context-window" id="ringContextWindow"></div>
      </div>
      <div class="snapshot-overlay-list" id="ringEntries"></div>
      <div class="overlay-actions">
        <button class="secondary-btn" id="ringSetMainline">LOCK MAINLINE</button>
        <button class="secondary-btn" data-close="ringOverlay">CLOSE</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="perspectiveOverlay">
    <div class="perspective-overlay-content" id="perspectiveOverlayContent">
      <button class="close-overlay" data-close="perspectiveOverlay">×</button>
    </div>
  </div>

  <input type="file" id="importInput" accept="application/json" hidden>

  <button class="corner-btn top-left" id="cornerKey" title="API Key">◎</button>
  <button class="corner-btn top-right" id="cornerHelp" title="Help">?</button>
  <button class="corner-btn bottom-left" id="cornerExchange" title="Import / Export">⇆</button>
  <button class="corner-btn bottom-right" id="cornerAdd" title="Add Channel">＋</button>

  <div class="corner-menu" id="infoMenu" style="top: calc(72px + env(safe-area-inset-top)); right: calc(16px + env(safe-area-inset-right));">
    <button data-action="help">HELP OVERVIEW</button>
    <button data-action="theme">TOGGLE THEME</button>
    <button data-action="fullscreen">FULLSCREEN MODE</button>
  </div>

  <div class="corner-menu" id="exchangeMenu" style="bottom: calc(72px + env(safe-area-inset-bottom)); left: calc(16px + env(safe-area-inset-left));">
    <button data-action="export">EXPORT SESSION</button>
    <button data-action="import">IMPORT SESSION</button>
  </div>

  <script>
    const blockPalette = [
      { type: 'Location', symbol: 'L' },
      { type: 'Entity', symbol: 'E' },
      { type: 'Goal', symbol: 'G' },
      { type: 'Obstacle', symbol: 'O' },
      { type: 'Shift', symbol: 'S' },
      { type: 'Solution', symbol: 'U' }
    ];

    const scenarios = {
      blank: {
        id: 'blank',
        name: 'Blank Canvas',
        role: 'Narrative Architect',
        goal: 'Invent any LEGOS world',
        obstacle: 'Unstructured possibility',
        intro: 'Start fresh. Describe locations, entities, goals, obstacles, shifts, solutions.',
        context: [
          'Use the grid intentionally—max 18 placements per scene.',
          'You can still request tetrads and snapshots even without a preset scenario.'
        ],
        initialPrompt: '',
        systemInstruction: 'You are orchestrating a generic LEGOS narrative. Preserve grid rigor and report explicit placements.'
      },
      maya: {
        id: 'maya',
        name: 'Maya Chen',
        role: 'L&D Lead @ Agronica',
        goal: 'Expose compulsive design patterns',
        obstacle: 'VP Growth blocking truth',
        intro: 'GrowthPath hides compulsive research. Maya needs board-level traction.',
        context: [
          'Constraints: Mortgage, dependent family, review due in two weeks.',
          'Power: Maya 0.20 vs VP 0.85. Chart strategic leverage moves.'
        ],
        initialPrompt: 'Maya brings fresh compulsive-usage data to a board prep session.',
        systemInstruction: 'You are the Maya Chen scenario orchestrator. Track power dynamics, board politics, and ethical stakes with precision.'
      },
      dev: {
        id: 'dev',
        name: 'Dev Kumar',
        role: 'Lead ML Engineer',
        goal: 'Fix bias in TalentFarm AI',
        obstacle: 'VP Engineering under launch pressure',
        intro: 'Launch looms with 3.2× discrimination. Dev balances ethics vs visa risk.',
        context: [
          'Constraints: H-1B visa, remittances, green card in process.',
          'Power: Dev 0.22 vs VP 0.82. Chart safe but effective escalations.'
        ],
        initialPrompt: 'Dev presents fairness metrics exposing discrimination just before launch sign-off.',
        systemInstruction: 'You orchestrate Dev Kumar’s ethical intervention. Balance bias mitigation, immigration precarity, and organizational politics.'
      }
    };

    const forkLabels = {
      continue: 'Continue',
      enhance: 'Enhance',
      reverse: 'Reverse',
      retrieve: 'Retrieve',
      obsolesce: 'Obsolesce',
      perspective: 'Perspective',
      snapshot: 'Snapshot',
      blank: 'Blank'
    };

    const themes = [
      { id: 'theme-crt', label: 'CRT GREEN' },
      { id: 'theme-parchment', label: 'PARCHMENT' },
      { id: 'theme-thousand', label: 'THOUSAND LIVES' }
    ];

    const channelColorPalette = ['#ff3d4e', '#56ff9f', '#f8d66a', '#7d8bff', '#ff8bf2', '#ffa53d', '#74d3ff'];
    let channelColorIndex = 0;
    let channelSequence = 1;

    const ringMemory = {
      capacity: 48,
      entries: [],
      pointer: 0,
      mainline: null,
      contextMode: 'all',
      contextAnchor: null
    };
    let ringEntryCounter = 1;
    const MAX_HANDLE_LENGTH = 10;

    function nextRingId() {
      return `R${String(ringEntryCounter++).padStart(4, '0')}`;
    }

    function nextChannelColor() {
      const color = channelColorPalette[channelColorIndex % channelColorPalette.length];
      channelColorIndex += 1;
      return color;
    }

    function generateSymbolicId() {
      return `CH${String(channelSequence++).padStart(8, '0')}`;
    }

    function resolveChannelName(name, scenarioId, symbolicId) {
      const scenarioName = scenarios[scenarioId]?.name || '';
      return sanitizeHandle(name || scenarioName || symbolicId, symbolicId);
    }

    function sanitizeHandle(text, fallback = 'UNTITLED') {
      const safeFallback = (fallback || 'UNTITLED').toUpperCase();
      const value = (text || '').toUpperCase().replace(/[^A-Z0-9]/g, ' ').replace(/\s+/g, ' ').trim();
      const base = value || safeFallback;
      return base.slice(0, MAX_HANDLE_LENGTH);
    }

    function sanitizeLabel(text) {
      if (!text) return '';
      // Don't truncate - keep full word names
      return text.replace(/[^a-zA-Z0-9\s]/g, '').trim();
    }

    function lightenColor(hex, amount = 0.2) {
      const num = parseInt(hex.replace('#', ''), 16);
      const r = Math.min(255, Math.round(((num >> 16) & 0xff) + 255 * amount));
      const g = Math.min(255, Math.round(((num >> 8) & 0xff) + 255 * amount));
      const b = Math.min(255, Math.round((num & 0xff) + 255 * amount));
      return `rgb(${r}, ${g}, ${b})`;
    }

    function logRingEntry(payload = {}) {
      const channelHandle = payload.channelName
        ? sanitizeHandle(payload.channelName, 'GLOBAL')
        : sanitizeHandle(channelMap.get(payload.channelId || '')?.name || 'GLOBAL', 'GLOBAL');
      const typeToken = sanitizeHandle(payload.type || 'NOTE', 'NOTE');
      const entry = {
        id: nextRingId(),
        timestamp: new Date().toISOString(),
        channelId: payload.channelId || null,
        channelName: channelHandle,
        type: typeToken,
        symbol: sanitizeHandle(payload.symbol || payload.channelName || 'ENTRY', 'ENTRY'),
        headline: payload.headline || '',
        summary: payload.summary || ''
      };
      ringMemory.entries.push(entry);
      if (ringMemory.entries.length > ringMemory.capacity) {
        const removed = ringMemory.entries.shift();
        if (removed?.id === ringMemory.mainline) {
          ringMemory.mainline = null;
        }
        if (removed?.id === ringMemory.contextAnchor) {
          ringMemory.contextAnchor = null;
        }
      }
      if (!ringMemory.contextAnchor) {
        ringMemory.contextAnchor = entry.id;
      }
      renderRingBar();
      renderRingContext();
      return entry;
    }

    function renderRingBar() {
      const bar = document.getElementById('ringBar');
      if (!bar) return;
      bar.innerHTML = '';
      ringMemory.entries.slice(-ringMemory.capacity).forEach(entry => {
        const dot = document.createElement('button');
        dot.className = 'ring-entry';
        dot.dataset.entryId = entry.id;
        dot.title = `${entry.symbol} · ${entry.type}`;
        dot.setAttribute('aria-label', `${entry.symbol} ${entry.type}`);
        if (entry.id === ringMemory.mainline) {
          dot.classList.add('mainline');
        }
        if (entry.id === (ringMemory.contextAnchor || ringMemory.mainline)) {
          dot.classList.add('active');
        }
        const channel = channelMap.get(entry.channelId || '') || null;
        if (channel) {
          dot.style.borderColor = channel.channelColor;
          dot.style.backgroundColor = lightenColor(channel.channelColor, 0.12);
        }
        dot.addEventListener('click', (event) => {
          event.stopPropagation();
          openRingOverlay(entry.id);
        });
        bar.appendChild(dot);
      });
    }

    function openRingOverlay(entryId) {
      const overlay = document.getElementById('ringOverlay');
      if (!overlay) return;
      const status = document.getElementById('ringStatus');
      const list = document.getElementById('ringEntries');
      const entry = ringMemory.entries.find(e => e.id === entryId)
        || ringMemory.entries[ringMemory.entries.length - 1]
        || null;
      if (!entry) {
        status.textContent = 'No entry selected.';
        list.innerHTML = '';
        renderRingContext();
        syncRingContextButtons();
        overlay.classList.add('active');
        return;
      }
      ringMemory.contextAnchor = entry.id;
      persistState();
      status.textContent = `${entry.symbol} · ${entry.type} · ${new Date(entry.timestamp).toLocaleString()}`;
      list.innerHTML = '';
      const item = document.createElement('div');
      item.className = 'snapshot-overlay-item';
      const meta = document.createElement('div');
      meta.className = 'snapshot-overlay-meta';
      meta.innerHTML = `<span>${entry.channelName || 'GLOBAL'}</span><span>${entry.id}</span>`;
      item.appendChild(meta);
      if (entry.headline) {
        const headline = document.createElement('div');
        headline.className = 'overlay-value';
        headline.textContent = entry.headline;
        item.appendChild(headline);
      }
      if (entry.summary) {
        const summary = document.createElement('div');
        summary.className = 'overlay-value';
        summary.textContent = entry.summary;
        item.appendChild(summary);
      }
      const actions = document.createElement('div');
      actions.className = 'snapshot-overlay-actions';
      const bindBtn = document.createElement('button');
      bindBtn.className = 'secondary-btn';
      bindBtn.textContent = 'BIND HERE';
      bindBtn.addEventListener('click', () => {
        if (!appState.currentChannelId) return;
        const channel = channelMap.get(appState.currentChannelId);
        if (!channel) return;
        channel.ringBinding = entry.id;
        refreshChannelHeader(channel);
        persistState();
        overlay.classList.remove('active');
      });
      const forkBtn = document.createElement('button');
      forkBtn.className = 'primary-btn';
      forkBtn.textContent = 'FORK CHANNEL';
      forkBtn.addEventListener('click', () => {
        if (!appState.currentChannelId) return;
        const channel = channelMap.get(appState.currentChannelId);
        if (!channel) return;
        const baseMessage = channel.messages[channel.messages.length - 1] || { id: null };
        forkChannel(channel, baseMessage, 'continue', { ringEntryId: entry.id });
        overlay.classList.remove('active');
      });
      actions.appendChild(bindBtn);
      actions.appendChild(forkBtn);
      item.appendChild(actions);
      list.appendChild(item);
      renderRingContext();
      syncRingContextButtons();
      const mainlineBtn = document.getElementById('ringSetMainline');
      if (mainlineBtn) {
        mainlineBtn.disabled = entry.id === ringMemory.mainline;
        mainlineBtn.dataset.entryId = entry.id;
      }
      overlay.classList.add('active');
    }

    function setRingContextMode(mode) {
      const allowed = ['all', 'anchor', 'mainline'];
      if (!allowed.includes(mode)) return;
      if (mode === 'mainline' && !ringMemory.mainline) {
        ringMemory.contextMode = 'all';
        showHelpBanner('Lock a mainline entry to follow it.');
      } else {
        ringMemory.contextMode = mode;
      }
      if (ringMemory.contextMode === 'mainline' && ringMemory.mainline) {
        ringMemory.contextAnchor = ringMemory.mainline;
      }
      renderRingContext();
      syncRingContextButtons();
      persistState();
    }

    function buildRingContextLine(entry) {
      const time = new Date(entry.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      const headline = entry.headline || entry.summary || '—';
      const compact = headline.length > 46 ? `${headline.slice(0, 46)}…` : headline;
      return [
        entry.id.padEnd(5),
        entry.symbol.padEnd(MAX_HANDLE_LENGTH),
        entry.type.padEnd(MAX_HANDLE_LENGTH),
        entry.channelName.padEnd(MAX_HANDLE_LENGTH),
        time,
        '·',
        compact
      ].join(' ');
    }

    function renderRingContext() {
      const contextWindow = document.getElementById('ringContextWindow');
      if (!contextWindow) return;
      if (!ringMemory.entries.length) {
        contextWindow.textContent = 'No entries logged.';
        return;
      }
      let anchor = ringMemory.entries.find(e => e.id === ringMemory.contextAnchor) || null;
      if (!anchor) {
        anchor = ringMemory.entries[ringMemory.entries.length - 1];
        ringMemory.contextAnchor = anchor?.id || null;
      }
      let source = ringMemory.entries;
      if (ringMemory.contextMode === 'anchor' && anchor?.channelId) {
        source = ringMemory.entries.filter(entry => entry.channelId === anchor.channelId);
      } else if (ringMemory.contextMode === 'mainline' && ringMemory.mainline) {
        const mainEntry = ringMemory.entries.find(entry => entry.id === ringMemory.mainline);
        if (mainEntry?.channelId) {
          source = ringMemory.entries.filter(entry => entry.channelId === mainEntry.channelId);
        } else if (mainEntry) {
          source = ringMemory.entries;
        } else {
          source = ringMemory.entries;
          ringMemory.contextMode = 'all';
        }
      }
      const slice = source.slice(-24);
      contextWindow.textContent = slice.length
        ? slice.map(buildRingContextLine).join('\n')
        : 'No entries to display.';
      syncRingContextButtons();
    }

    function syncRingContextButtons() {
      const buttons = document.querySelectorAll('.ring-context-btn');
      buttons.forEach(btn => {
        const mode = btn.getAttribute('data-mode');
        if (mode === 'mainline') {
          btn.disabled = !ringMemory.mainline;
        }
        btn.classList.toggle('active', mode === ringMemory.contextMode && (!btn.disabled || mode !== 'mainline'));
      });
    }

    let themeButtonRef = null;

    const deepClone = (value) => {
      if (typeof structuredClone === 'function') {
        return structuredClone(value);
      }
      return JSON.parse(JSON.stringify(value));
    };

    const createEmptyGrid = () => Array.from({ length: 9 }, () => Array(9).fill(null));

    const createDefaultObserver = () => ({
      plot: {
        prior: { caution: 0.5, progress: 0.5 },
        posterior: { caution: 0.5, progress: 0.5 }
      },
      direction: 'up',
      tension: 0.4,
      narrative: 'Awaiting first scene.'
    });

    const createDefaultScorecard = () => ({
      progress: 0,
      caution: 0,
      movesRemaining: 0,
      goalDistance: 0
    });

    class Channel {
      constructor(config = {}) {
        this.id = config.id || `ch-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;
        this.symbolicId = config.symbolicId || generateSymbolicId();
        this.channelColor = config.channelColor || nextChannelColor();
        this.name = resolveChannelName(config.name, config.scenario || 'blank', this.symbolicId);
        this.scenario = config.scenario || 'blank';
        this.systemInstruction = config.systemInstruction || scenarios[this.scenario].systemInstruction;
        this.messages = (config.messages || []).map(msg => ({ ...msg }));
        this.grid = config.grid ? deepClone(config.grid) : createEmptyGrid();
        this.cells = config.cells ? deepClone(config.cells) : {};
        this.ledger = config.ledger ? deepClone(config.ledger) : [];
        this.snapshots = config.snapshots ? deepClone(config.snapshots) : [];
        this.observer = config.observer ? deepClone(config.observer) : createDefaultObserver();
        this.scorecard = config.scorecard ? deepClone(config.scorecard) : createDefaultScorecard();
        this.tetrad = config.tetrad ? deepClone(config.tetrad) : {};
        this.lastScene = config.lastScene ? deepClone(config.lastScene) : null;
        this.parentChannelId = config.parentChannelId || null;
        this.forkPoint = config.forkPoint || null;
        this.collapsed = config.collapsed || false;
        this.pending = false;
        this.pendingTetrad = false;
        this.ringBinding = config.ringBinding || null;
        this.dom = null;
        const messageIds = this.messages
          .map(m => parseInt(String(m.id).replace(/[^0-9]/g, ''), 10))
          .filter(Number.isFinite);
        this.messageCounter = messageIds.length ? Math.max(...messageIds) : 0;
      }

      serialize() {
        return {
          id: this.id,
          name: this.name,
          symbolicId: this.symbolicId,
          channelColor: this.channelColor,
          ringBinding: this.ringBinding,
          scenario: this.scenario,
          systemInstruction: this.systemInstruction,
          messages: this.messages,
          grid: this.grid,
          cells: this.cells,
          ledger: this.ledger,
          snapshots: this.snapshots,
          observer: this.observer,
          scorecard: this.scorecard,
          tetrad: this.tetrad,
          lastScene: this.lastScene,
          parentChannelId: this.parentChannelId,
          forkPoint: this.forkPoint,
          collapsed: this.collapsed
        };
      }

      resetState(options = {}) {
        if (!options.preserveMessages) {
          this.messages = [];
          this.messageCounter = 0;
        }
        this.grid = createEmptyGrid();
        this.cells = {};
        this.ledger = [];
        this.snapshots = [];
        this.observer = createDefaultObserver();
        this.scorecard = createDefaultScorecard();
        this.tetrad = {};
        this.lastScene = null;
        this.pendingTetrad = false;
      }

      addMessage(role, text, extra = {}) {
        const entry = {
          id: extra.id || `M${String(++this.messageCounter).padStart(4, '0')}`,
          role,
          text,
          timestamp: extra.timestamp || new Date().toISOString(),
          autoCollapse: extra.autoCollapse || false,
          forkLabel: extra.forkLabel || null,
          fromChannel: extra.fromChannel || null,
          sceneId: extra.sceneId || null
        };
        this.messages.push(entry);
        return entry;
      }

      createSnapshot(name) {
        const snapshot = {
          id: `snap-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,
          name: sanitizeHandle(name || `SNAPSHOT ${this.snapshots.length + 1}`, 'SNAPSHOT'),
          timestamp: new Date().toISOString(),
          grid: deepClone(this.grid),
          cells: deepClone(this.cells),
          observer: deepClone(this.observer),
          scorecard: deepClone(this.scorecard),
          tetrad: deepClone(this.tetrad),
          lastScene: deepClone(this.lastScene),
          ledgerLength: this.ledger.length
        };
        this.snapshots.push(snapshot);
        return snapshot;
      }
    }

    const appState = {
      apiKey: localStorage.getItem('legos/multiChannelKey') || '',
      channels: [],
      currentChannelId: null,
      theme: localStorage.getItem('legos/multiChannelTheme') || themes[0].id
    };

    document.body.classList.add(appState.theme);

    const channelMap = new Map();
    let snapshotOverlayChannel = null;

    function initApp() {
      bindGlobalControls();
      loadState();
      if (!appState.channels.length) {
        const maya = createChannel({ scenario: 'maya', name: 'MAYA PRIME' });
        const dev = createChannel({ scenario: 'dev', name: 'DEV FIELD' });
        appState.currentChannelId = maya.id;
        setTimeout(() => focusChannel(maya.id), 300);
        persistState();
      }
      renderTimeline();
      refreshAllChannels();
      renderRingBar();
      renderRingContext();
      syncRingContextButtons();
      
      // Setup visibility observer after DOM is ready
      setTimeout(() => {
        setupChannelVisibilityObserver();
      }, 100);
      
      if (!appState.apiKey) {
        showHelpBanner('Tap ◎ to store an OpenAI key for scene assembly.');
      }
    }

    function bindGlobalControls() {
      const keyBtn = document.getElementById('cornerKey');
      const keyOverlay = document.getElementById('keyOverlay');
      const keyInput = document.getElementById('keyInput');
      const keySaveBtn = document.getElementById('keySaveBtn');
      const keyStatus = document.getElementById('keyStatus');
      keyBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        keyInput.value = appState.apiKey || '';
        keyStatus.textContent = appState.apiKey ? 'Key stored locally.' : 'Key not stored.';
        keyOverlay.classList.add('active');
      });
      keySaveBtn.addEventListener('click', () => {
        const value = keyInput.value.trim();
        if (!value.startsWith('sk-') || value.length < 20) {
          keyStatus.textContent = 'Invalid key format.';
          return;
        }
        appState.apiKey = value;
        localStorage.setItem('legos/multiChannelKey', value);
        keyStatus.textContent = 'Key stored.';
        keyOverlay.classList.remove('active');
        showHelpBanner('API key saved. Channels will auto-compose scenes.');
      });
      themeButtonRef = null;

      document.querySelectorAll('[data-close]').forEach(btn => {
        btn.addEventListener('click', () => {
          const targetId = btn.getAttribute('data-close');
          const target = document.getElementById(targetId);
          if (target) target.classList.remove('active');
          if (targetId === 'snapshotOverlay') {
            snapshotOverlayChannel = null;
          }
        });
      });

      document.getElementById('cornerAdd').addEventListener('click', (event) => {
        event.stopPropagation();
        const channel = createChannel({ scenario: 'blank' });
        focusChannel(channel.id);
        showHelpBanner('New blank channel ready. Compose or fork into it.');
      });

      const importInput = document.getElementById('importInput');
      importInput.addEventListener('change', handleImportFile);

      const infoBtn = document.getElementById('cornerHelp');
      const infoMenu = document.getElementById('infoMenu');
      infoBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleMenu(infoMenu);
      });
      infoMenu.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', (event) => {
          const action = event.currentTarget.getAttribute('data-action');
          if (action === 'help') {
            showHelpBanner('HYPERCLAY: Write what happens next • ADD entities/objects • REMOVE elements • Transform states • Introduce complications • Resolve obstacles • The world is malleable | Tap messages to fork • Use snapshots to time-travel');
          } else if (action === 'theme') {
            const idx = themes.findIndex(t => t.id === appState.theme);
            const next = themes[(idx + 1) % themes.length];
            applyTheme(next.id);
            showHelpBanner(`Theme switched to ${themes.find(t => t.id === appState.theme)?.label || 'CRT GREEN'}.`);
          } else if (action === 'fullscreen') {
            if (!document.fullscreenElement) {
              document.body.requestFullscreen().catch(err => console.warn('Fullscreen failed:', err));
            } else {
              document.exitFullscreen();
            }
          }
          infoMenu.classList.remove('visible');
        });
      });
      infoMenu.addEventListener('click', (event) => event.stopPropagation());

      const exchangeBtn = document.getElementById('cornerExchange');
      const exchangeMenu = document.getElementById('exchangeMenu');
      exchangeBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleMenu(exchangeMenu);
      });
      exchangeMenu.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', (event) => {
          const action = event.currentTarget.getAttribute('data-action');
          if (action === 'export') {
            document.getElementById('exportOverlay').classList.add('active');
          } else if (action === 'import') {
            importInput.click();
          }
          exchangeMenu.classList.remove('visible');
        });
      });
      exchangeMenu.addEventListener('click', (event) => event.stopPropagation());

      // Initialize global footer
      const globalScenarioSelect = document.getElementById('globalScenarioSelect');
      const globalTetradBtn = document.getElementById('globalTetradBtn');

      // Populate scenario selector
      Object.values(scenarios).forEach(sc => {
        const option = document.createElement('option');
        option.value = sc.id;
        const displayName = sc.name.length > 20 ? sc.name.substring(0, 19) + '\u2026' : sc.name;
        option.textContent = displayName.toUpperCase();
        globalScenarioSelect.appendChild(option);
      });

      // Update scenario for active channel
      globalScenarioSelect.addEventListener('change', () => {
        const activeChannel = appState.channels.find(ch => ch.id === appState.currentChannelId);
        if (activeChannel) {
          setChannelScenario(activeChannel, globalScenarioSelect.value);
          if (activeChannel.dom?.lineageEl) {
            activeChannel.dom.lineageEl.textContent = `${scenarios[activeChannel.scenario].name.toUpperCase()} \u00b7 ${scenarios[activeChannel.scenario].role}`;
          }
        }
      });
      
      // Tetrad button - opens perspective selector (tetrad auto-generates)
      globalTetradBtn.addEventListener('click', () => {
        const activeChannel = appState.channels.find(ch => ch.id === appState.currentChannelId);
        if (activeChannel) {
          openPerspectiveSelector(activeChannel);
        }
      });
      

      document.getElementById('confirmExport').addEventListener('click', exportState);

      document.addEventListener('click', () => {
        infoMenu.classList.remove('visible');
        exchangeMenu.classList.remove('visible');
      });

      document.querySelectorAll('.ring-context-btn').forEach(btn => {
        btn.addEventListener('click', (event) => {
          event.stopPropagation();
          const mode = btn.getAttribute('data-mode');
          setRingContextMode(mode);
        });
      });

      const ringMainBtn = document.getElementById('ringSetMainline');
      if (ringMainBtn) {
        ringMainBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          const targetId = ringMainBtn.dataset.entryId || ringMemory.contextAnchor;
          if (!targetId) return;
          ringMemory.mainline = targetId;
          renderRingBar();
          renderRingContext();
          syncRingContextButtons();
          persistState();
          showHelpBanner(`Mainline locked: ${targetId}`);
        });
      }

      applyTheme(appState.theme);
    }

    function showHelpBanner(text) {
      const existing = document.querySelector('.help-banner');
      if (existing) existing.remove();
      const banner = document.createElement('div');
      banner.className = 'help-banner';
      banner.textContent = text;
      banner.style.position = 'fixed';
      banner.style.left = '50%';
      banner.style.bottom = '24px';
      banner.style.transform = 'translateX(-50%)';
      banner.style.background = 'var(--panel)';
      banner.style.border = '1px solid var(--border)';
      banner.style.padding = '12px 18px';
      banner.style.letterSpacing = '0.2em';
      banner.style.fontSize = '8px';
      banner.style.color = 'var(--text)';
      banner.style.zIndex = '30';
      banner.style.borderRadius = '4px';
      banner.style.boxShadow = '0 12px 32px var(--shadow)';
      document.body.appendChild(banner);
      setTimeout(() => banner.remove(), 3200);
    }

    function toggleMenu(menu) {
      if (!menu) return;
      const alreadyVisible = menu.classList.contains('visible');
      document.querySelectorAll('.corner-menu.visible').forEach(item => item.classList.remove('visible'));
      if (!alreadyVisible) {
        menu.classList.add('visible');
      }
    }

    function applyTheme(themeId) {
      themes.forEach(theme => document.body.classList.remove(theme.id));
      document.body.classList.add(themeId);
      appState.theme = themeId;
      localStorage.setItem('legos/multiChannelTheme', themeId);
      updateThemeButtonLabel();
    }

    function updateThemeButtonLabel() {
      if (!themeButtonRef) return;
      const meta = themes.find(t => t.id === appState.theme) || themes[0];
      themeButtonRef.textContent = `THEME · ${meta.label}`;
    }

    function loadState() {
      try {
        const raw = localStorage.getItem('legos/multiChannelState');
        if (!raw) return;
        const data = JSON.parse(raw);
        (data.channels || []).forEach(cfg => {
          const channel = new Channel(cfg);
          channel.name = resolveChannelName(channel.name, channel.scenario, channel.symbolicId);
          if (!channel.channelColor) {
            channel.channelColor = nextChannelColor();
          }
          const numeric = parseInt((channel.symbolicId || '').replace(/[^0-9]/g, ''), 10);
          if (!Number.isNaN(numeric)) {
            channelSequence = Math.max(channelSequence, numeric + 1);
          }
          channelMap.set(channel.id, channel);
          appState.channels.push(channel);
          mountChannel(channel);
        });
        channelColorIndex = appState.channels.length % channelColorPalette.length;
        appState.currentChannelId = data.currentChannelId || (appState.channels[0]?.id ?? null);
        if (data.ring) {
          const restoredEntries = (data.ring.entries || []).map(entry => ({
            ...entry,
            channelName: sanitizeHandle(entry.channelName || 'GLOBAL', 'GLOBAL'),
            symbol: sanitizeHandle(entry.symbol || entry.channelName || 'ENTRY', 'ENTRY'),
            type: sanitizeHandle(entry.type || 'NOTE', 'NOTE')
          }));
          ringMemory.entries = restoredEntries.slice(-ringMemory.capacity);
          ringMemory.mainline = data.ring.mainline || null;
          ringMemory.contextMode = data.ring.contextMode || 'all';
          ringMemory.contextAnchor = data.ring.contextAnchor
            || ringMemory.entries[ringMemory.entries.length - 1]?.id
            || null;
          const storedCounter = parseInt(data.ring.counter, 10);
          if (Number.isFinite(storedCounter) && storedCounter > ringEntryCounter) {
            ringEntryCounter = storedCounter;
          } else if (ringMemory.entries.length && !storedCounter) {
            const numeric = ringMemory.entries
              .map(entry => parseInt(String(entry.id).replace(/[^0-9]/g, ''), 10))
              .filter(Number.isFinite);
            if (numeric.length) {
              ringEntryCounter = Math.max(...numeric) + 1;
            }
          }
        }
      } catch (err) {
        console.error('Failed to load state', err);
        localStorage.removeItem('legos/multiChannelState');
      }
    }

    function persistState() {
      const payload = {
        currentChannelId: appState.currentChannelId,
        channels: appState.channels.map(ch => ch.serialize()),
        ring: {
          entries: ringMemory.entries,
          mainline: ringMemory.mainline,
          contextMode: ringMemory.contextMode,
          contextAnchor: ringMemory.contextAnchor,
          counter: ringEntryCounter
        }
      };
      localStorage.setItem('legos/multiChannelState', JSON.stringify(payload));
    }

    function createChannel(config = {}) {
      const payload = { ...config };
      if (!payload.symbolicId) {
        payload.symbolicId = generateSymbolicId();
      }
      if (!payload.channelColor) {
        payload.channelColor = nextChannelColor();
      }
      payload.name = resolveChannelName(payload.name, payload.scenario || 'blank', payload.symbolicId);
      const channel = new Channel(payload);
      channelMap.set(channel.id, channel);
      appState.channels.push(channel);
      mountChannel(channel);
      appState.currentChannelId = channel.id;
      persistState();
      return channel;
    }

    function mountChannel(channel) {
      const scroller = document.getElementById('channelScroller');
      const column = document.createElement('section');
      column.className = 'channel-column';
      column.dataset.channelId = channel.id;

      const header = document.createElement('div');
      header.className = 'channel-head';

      const meta = document.createElement('div');
      meta.className = 'channel-meta';
      const name = document.createElement('div');
      name.className = 'channel-name';
      const lineage = document.createElement('div');
      lineage.className = 'channel-lineage';
      meta.appendChild(name);
      meta.appendChild(lineage);

      const actions = document.createElement('div');
      actions.className = 'channel-actions';

      const ringOverviewBtn = document.createElement('button');
      ringOverviewBtn.className = 'channel-btn';
      ringOverviewBtn.title = 'Ring Memory Overview';
      ringOverviewBtn.textContent = '◎';
      ringOverviewBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        openRingOverview(channel);
      });

      const snapshotBtn = document.createElement('button');
      snapshotBtn.className = 'channel-btn';
      snapshotBtn.title = 'Snapshots';
      snapshotBtn.textContent = '⧉';
      snapshotBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        openSnapshotOverlay(channel);
      });

      const gridToggleBtn = document.createElement('button');
      gridToggleBtn.className = 'channel-btn';
      gridToggleBtn.title = 'Toggle grid';
      gridToggleBtn.textContent = '▼';

      const collapseBtn = document.createElement('button');
      collapseBtn.className = 'channel-btn';
      collapseBtn.title = 'Collapse column';
      collapseBtn.textContent = '‹';
      
      // Add expand tab for collapsed state
      const expandTab = document.createElement('div');
      expandTab.className = 'channel-expand-tab';
      expandTab.style.cssText = `
        position: absolute;
        left: 52px;
        top: 50%;
        transform: translateY(-50%);
        width: 32px;
        height: 100px;
        background: var(--panel);
        border: 2px solid var(--border);
        border-left: none;
        border-radius: 0 8px 8px 0;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
        cursor: pointer;
        z-index: 50;
        box-shadow: 2px 0 8px var(--shadow);
        transition: all 0.2s var(--transition);
      `;
      
      const expandDot = document.createElement('div');
      expandDot.style.cssText = `
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: ${channel.channelColor};
        border: 1px solid var(--border);
      `;
      
      const expandArrow = document.createElement('div');
      expandArrow.style.cssText = `
        font-size: 16px;
        color: var(--text-muted);
      `;
      expandArrow.textContent = '›';
      
      expandTab.appendChild(expandDot);
      expandTab.appendChild(expandArrow);
      
      expandTab.addEventListener('mouseenter', () => {
        expandTab.style.background = 'var(--accent)';
        expandArrow.style.color = 'var(--bg)';
      });
      
      expandTab.addEventListener('mouseleave', () => {
        expandTab.style.background = 'var(--panel)';
        expandArrow.style.color = 'var(--text-muted)';
      });
      
      expandTab.addEventListener('click', () => {
        column.classList.remove('collapsed');
        channel.collapsed = false;
        collapseBtn.textContent = '‹';
        expandTab.style.display = 'none';
        persistState();
      });
      column.appendChild(expandTab);
      
      // Update collapse button to show/hide expand tab
      collapseBtn.addEventListener('click', () => {
        column.classList.toggle('collapsed');
        channel.collapsed = column.classList.contains('collapsed');
        collapseBtn.textContent = channel.collapsed ? '›' : '‹';
        expandTab.style.display = channel.collapsed ? 'flex' : 'none';
        persistState();
      });
      
      if (channel.collapsed) {
        column.classList.add('collapsed');
        collapseBtn.textContent = '›';
        expandTab.style.display = 'flex';
      }

      const resetBtn = document.createElement('button');
      resetBtn.className = 'channel-btn';
      resetBtn.title = 'Reset channel';
      resetBtn.textContent = '↺';
      resetBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        if (!confirm('Clear grid, history, and snapshots for this channel?')) return;
        channel.resetState();
        if (snapshotOverlayChannel === channel) {
          snapshotOverlayChannel = null;
          const overlay = document.getElementById('snapshotOverlay');
          if (overlay) overlay.classList.remove('active');
        }
        addMessageToChannel(channel, 'system', 'Channel reset. Start a fresh beat.');
        renderChannel(channel);
        persistState();
      });
      actions.appendChild(gridToggleBtn);
      actions.appendChild(ringOverviewBtn);
      actions.appendChild(snapshotBtn);
      actions.appendChild(resetBtn);
      actions.appendChild(collapseBtn);

      header.appendChild(meta);
      header.appendChild(actions);

      const body = document.createElement('div');
      body.className = 'channel-body';

      const gridSection = document.createElement('div');
      gridSection.className = 'grid-section';
      // Grid toggle button event handler
      let gridCollapsed = false;
      gridToggleBtn.addEventListener('click', () => {
        gridCollapsed = !gridCollapsed;
        gridSection.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
        
        if (gridCollapsed) {
          // Animate cells before collapse
          const cells = gridSection.querySelectorAll('.grid-cell');
          cells.forEach((cell, idx) => {
            cell.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
            cell.style.transitionDelay = `${idx * 0.01}s`;
            cell.style.transform = 'scale(0.8)';
            cell.style.opacity = '0';
          });
          
          setTimeout(() => {
            gridSection.style.maxHeight = '0';
            gridSection.style.padding = '0';
            gridSection.style.opacity = '0';
            gridSection.style.overflow = 'hidden';
            gridToggleBtn.textContent = '▼';
            body.classList.add('grid-collapsed');
          }, 200);
        } else {
          gridSection.style.maxHeight = '';
          gridSection.style.padding = '';
          gridSection.style.opacity = '';
          gridSection.style.overflow = '';
          gridToggleBtn.textContent = '▲';
          body.classList.remove('grid-collapsed');
          
          // Animate cells on expand
          setTimeout(() => {
            const cells = gridSection.querySelectorAll('.grid-cell');
            cells.forEach((cell, idx) => {
              cell.style.transform = '';
              cell.style.opacity = '';
              cell.style.transitionDelay = `${idx * 0.01}s`;
            });
          }, 100);
        }
      });
      
      const gridHeader = document.createElement('div');
      gridHeader.className = 'grid-header';
      const gridTitle = document.createElement('div');
      gridTitle.className = 'grid-title';
      gridTitle.textContent = 'NARRATIVE GRID';

      gridHeader.appendChild(gridTitle);

      const gridArea = document.createElement('div');
      gridArea.className = 'grid-area';
      const channelNumberRail = document.createElement('div');
      channelNumberRail.className = 'channel-number-rail';
      gridArea.appendChild(channelNumberRail);

      const gridWrapper = document.createElement('div');
      gridWrapper.className = 'grid-wrapper';
      const grid = document.createElement('div');
      grid.className = 'grid';
      gridWrapper.appendChild(grid);
      gridArea.appendChild(gridWrapper);

      gridSection.appendChild(gridHeader);
      gridSection.appendChild(gridArea);

      const chatSection = document.createElement('div');
      chatSection.className = 'chat-section';
      const chatStream = document.createElement('div');
      chatStream.className = 'chat-stream';
      const messageDotRail = document.createElement('div');
      messageDotRail.className = 'message-dot-rail';
      const messageList = document.createElement('div');
      messageList.className = 'message-list';
      chatStream.appendChild(messageDotRail);
      chatStream.appendChild(messageList);

      const inputSection = document.createElement('div');
      inputSection.className = 'input-section';
      
      const inputWrapper = document.createElement('div');
      inputWrapper.className = 'input-wrapper';
      const textarea = document.createElement('textarea');
      textarea.className = 'message-input';
      textarea.rows = 3;
      textarea.placeholder = 'Start or transform the scene…';
      const sendBtn = document.createElement('button');
      sendBtn.className = 'send-btn';
      sendBtn.textContent = 'SEND';

      textarea.addEventListener('input', () => {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
        
        // Keep input visible while typing on mobile
        if (window.visualViewport && document.activeElement === textarea) {
          setTimeout(() => {
            inputSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }, 50);
        }
      });
      textarea.addEventListener('focus', () => {
        focusChannel(channel.id);
        
        // Mobile keyboard handling - scroll input into view
        setTimeout(() => {
          // Scroll the input section into view when keyboard appears
          inputSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          
          // For iOS Safari - ensure input is visible above keyboard
          if (window.visualViewport) {
            const viewportHeight = window.visualViewport.height;
            const inputRect = textarea.getBoundingClientRect();
            
            // If input is below viewport, scroll it up
            if (inputRect.bottom > viewportHeight) {
              const scrollAmount = inputRect.bottom - viewportHeight + 20;
              window.scrollBy(0, scrollAmount);
            }
          }
        }, 300); // Wait for keyboard animation
      });
      textarea.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
          event.preventDefault();
          sendBtn.click();
        }
      });

      sendBtn.addEventListener('click', () => {
        const value = textarea.value.trim();
        if (!value) return;
        addMessageToChannel(channel, 'user', value);
        textarea.value = '';
        textarea.style.height = 'auto';
        if (!appState.apiKey) {
          addMessageToChannel(channel, 'system', 'API key required for auto scene assembly. Store one via ◎.');
          persistState();
          return;
        }
        composeScene(channel, value);
      });

      inputWrapper.appendChild(textarea);
      inputWrapper.appendChild(sendBtn);
      inputSection.appendChild(inputWrapper);
      
      // Per-channel footer removed - now using global footer

      // Click anywhere in column to focus it
      column.addEventListener('click', (e) => {
        // Don't interfere with button clicks
        if (!e.target.closest('button, input, textarea, .grid-cell')) {
          focusChannel(channel.id);
        }
      });
      
      chatSection.appendChild(chatStream);
      chatSection.appendChild(inputSection);

      // Add resize bar between grid and chat
      const resizeBar = document.createElement('div');
      resizeBar.className = 'resize-bar';
      
      let isResizing = false;
      let startY = 0;
      let startHeight = 0;
      
      // Mouse events
      resizeBar.addEventListener('mousedown', (e) => {
        isResizing = true;
        startY = e.clientY;
        startHeight = gridSection.offsetHeight;
        document.body.style.cursor = 'row-resize';
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const deltaY = e.clientY - startY;
        let newHeight = startHeight + deltaY;
        
        // Clamp between 30vh and 70vh
        newHeight = Math.max(window.innerHeight * 0.3, Math.min(window.innerHeight * 0.7, newHeight));
        
        gridSection.style.height = newHeight + 'px';
        gridSection.style.flex = `0 0 ${newHeight}px`;
      });
      
      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          document.body.style.cursor = '';
        }
      });
      
      // Touch events for mobile
      resizeBar.addEventListener('touchstart', (e) => {
        isResizing = true;
        startY = e.touches[0].clientY;
        startHeight = gridSection.offsetHeight;
        e.preventDefault();
      });
      
      document.addEventListener('touchmove', (e) => {
        if (!isResizing) return;
        const deltaY = e.touches[0].clientY - startY;
        let newHeight = startHeight + deltaY;
        
        // Clamp between 30vh and 70vh
        newHeight = Math.max(window.innerHeight * 0.3, Math.min(window.innerHeight * 0.7, newHeight));
        
        gridSection.style.height = newHeight + 'px';
        gridSection.style.flex = `0 0 ${newHeight}px`;
      }, { passive: false });
      
      document.addEventListener('touchend', () => {
        if (isResizing) {
          isResizing = false;
        }
      });
      
      body.appendChild(gridSection);
      body.appendChild(resizeBar);
      body.appendChild(chatSection);

      // Activate channel on any click within the column
      column.addEventListener('click', (e) => {
        // Don't interfere with button clicks
        if (e.target.closest('button')) return;
        focusChannel(channel.id);
      });
      
      // Also activate on chat interaction
      chatSection.addEventListener('click', () => {
        focusChannel(channel.id);
      });

      column.appendChild(header);
      column.appendChild(body);
      scroller.appendChild(column);

      channel.dom = {
        column,
        header,
        nameEl: name,
        lineageEl: lineage,
        gridEl: grid,
        gridWrapper,
        gridTitle,
        messageList,
        messageDotRail,
        input: textarea,
        sendBtn,
        channelRail: channelNumberRail
      };

      refreshChannelHeader(channel);
      styleChannelControls(channel);
      renderChannel(channel);
    }

    function refreshChannelHeader(channel) {
      if (!channel || !channel.dom) return;
      const { nameEl, lineageEl, gridTitle } = channel.dom;
      if (nameEl) nameEl.textContent = channel.name;
      if (lineageEl) {
        if (channel.parentChannelId) {
          const parent = channelMap.get(channel.parentChannelId);
          const parentHandle = sanitizeHandle(parent?.name || 'PARENT', 'PARENT');
          lineageEl.textContent = `FORK · ${parentHandle}`;
          lineageEl.style.display = '';
        } else {
          lineageEl.textContent = '';
          lineageEl.style.display = 'none';
        }
      }
      if (gridTitle) {
        gridTitle.textContent = formatChannelHeadline(channel);
      }
    }

    function styleChannelControls(channel) {
      if (!channel || !channel.dom) return;
      const color = channel.channelColor || getComputedStyle(document.body).getPropertyValue('--accent');
      const { sendBtn, header, column } = channel.dom;
      const isActive = channel.id === appState.currentChannelId;
      
      // Mark inactive channels and set color variable
      if (column) {
        if (isActive) {
          column.classList.remove('inactive');
        } else {
          column.classList.add('inactive');
        }
        // Set CSS variable for channel color
        column.style.setProperty('--channel-color', color);
      }
      
      // Apply channel color to all buttons in header and footer
      const channelBtns = column?.querySelectorAll('.channel-btn');
      channelBtns?.forEach(btn => {
        btn.style.borderColor = color;
        btn.style.color = color;
      });
      
      // Send button gets full color
      if (sendBtn) {
        sendBtn.textContent = '➜';
        sendBtn.dataset.channelId = channel.id;
        sendBtn.style.background = color;
        sendBtn.style.color = 'var(--bg)';
        sendBtn.style.borderColor = color;
      }
      
      // Header and footer borders
      if (header) {
        header.style.borderColor = color;
      }
      
      const footer = column?.querySelector('.channel-footer');
      if (footer) {
        footer.style.borderColor = color;
      }
      
      
      // Grid cells get subtle accent
      const gridCells = column?.querySelectorAll('.grid-cell.occupied');
      gridCells?.forEach(cell => {
        cell.style.borderColor = color;
      });
      
      // Channel numbers in rail
      const channelNumbers = document.querySelectorAll('.channel-number');
      channelNumbers.forEach(num => {
        if (num.dataset.channelId === channel.id) {
          num.style.borderColor = color;
          num.style.background = color;
          num.style.color = 'var(--bg)';
          num.style.boxShadow = `0 0 12px ${color}40`;
        } else {
          // Grey out other channels
          num.style.opacity = '0.4';
        }
      });
      
      // Message dots get channel color
      const messageDots = column?.querySelectorAll('.message-dot');
      messageDots?.forEach(dot => {
        dot.style.color = color;
        dot.style.borderColor = color;
      });
    }

    function formatChannelHeadline(channel) {
      if (!channel) return '';
      const parts = [];
      parts.push(channel.symbolicId);
      const nameHandle = sanitizeHandle(channel.name, channel.symbolicId);
      if (nameHandle !== channel.symbolicId) {
        parts.push(nameHandle);
      }
      if (channel.forkPoint && channel.forkPoint.mode) {
        let label = channel.forkPoint.mode.toUpperCase();
        if (channel.forkPoint.mode === 'perspective') {
          label = 'POV';
        }
        parts.push(sanitizeHandle(label, 'FORK'));
      }
      if (channel.forkPoint && channel.forkPoint.coordinates) {
        const { x, y } = channel.forkPoint.coordinates;
        parts.push(sanitizeHandle(`CELL ${x}${y}`, 'CELL'));
      }
      if (channel.ringBinding) {
        const entry = ringMemory.entries.find(e => e.id === channel.ringBinding);
        if (entry && entry.symbol) {
          parts.push(entry.symbol);
        }
      }
      return parts
        .filter(Boolean)
        .map(part => sanitizeHandle(part, part))
        .join(' • ');
    }

    function renderChannel(channel) {
      refreshChannelHeader(channel);
      styleChannelControls(channel);
      renderChannelGrid(channel);
      renderChannelMessages(channel);
      renderTetradPanel(channel);
      renderTimeline();
      if (snapshotOverlayChannel === channel) {
        renderSnapshotOverlay();
      }
    }

    function renderGrid(channel) {
      const grid = channel.dom?.gridEl;
      if (!grid) return;
      grid.innerHTML = '';
      
      // Detect resonance fields (nearby entities)
      const entityPositions = [];
      channel.grid.forEach((row, y) => {
        row.forEach((cell, x) => {
          if (cell && cell.type === 'Entity') {
            entityPositions.push({ x, y });
          }
        });
      });
      channel.grid.forEach((row, y) => {
        row.forEach((cell, x) => {
          const div = document.createElement('div');
          div.className = 'grid-cell';
          
          // Check if this cell is in resonance field
          const isNearEntity = entityPositions.some(pos => {
            const distance = Math.abs(pos.x - x) + Math.abs(pos.y - y);
            return distance <= 2 && distance > 0;
          });
          
          if (isNearEntity && (!cell || cell.type !== 'Entity')) {
            div.classList.add('resonance-field');
          }
          
          if (cell) {
            div.classList.add('occupied');
            const palette = blockPalette.find(p => p.type === cell.type);
            div.textContent = cell.symbol || '?';
            div.style.color = palette?.color || 'var(--text)';
            
            // Rich tooltip
            let tooltip = `${cell.type}: ${cell.label || 'Unnamed'}`;
            if (cell.entity?.description) {
              tooltip += `\n${cell.entity.description.substring(0, 80)}${cell.entity.description.length > 80 ? '...' : ''}`;
            }
            if (cell.entity?.relations?.length) {
              tooltip += `\nRelations: ${cell.entity.relations.length}`;
            }
            const cellLogs = channel.cells[`${x},${y}`] || [];
            if (cellLogs.length) {
              tooltip += `\nEvents: ${cellLogs.length}`;
            }
            div.title = tooltip;
            
            if (cell.label) {
              // Add full name for hover tooltip
              div.setAttribute('data-full-name', cell.label.toUpperCase());
              
              const label = document.createElement('div');
              label.className = 'grid-label';
              // Truncate to 8 chars for consistent sizing
              const truncatedLabel = cell.label.length > 8 ? cell.label.slice(0, 7) + '…' : cell.label;
              label.textContent = truncatedLabel.toUpperCase();
              
              // Calculate luminance for contrast
              if (palette?.color) {
                const color = palette.color;
                let r, g, b;
                
                // Parse hex color
                if (color.startsWith('#')) {
                  const hex = color.slice(1);
                  r = parseInt(hex.slice(0, 2), 16);
                  g = parseInt(hex.slice(2, 4), 16);
                  b = parseInt(hex.slice(4, 6), 16);
                } else if (color.startsWith('rgb')) {
                  const match = color.match(/\d+/g);
                  if (match) {
                    [r, g, b] = match.map(Number);
                  }
                }
                
                if (r !== undefined && g !== undefined && b !== undefined) {
                  // Calculate relative luminance
                  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                  
                  // If bright color, use dark text
                  if (luminance > 0.6) {
                    label.classList.add('dark-text');
                  } else {
                    label.classList.add('light-text');
                  }
                }
              }
              
              div.appendChild(label);
            }
            div.dataset.cellType = cell.type;
          }
          div.dataset.x = x;
          div.dataset.y = y;
          div.addEventListener('click', () => {
            focusChannel(channel.id);
            openCellOverlay(channel, x, y);
          });
          grid.appendChild(div);
        });
      });
    }

    function renderChannelGrid(channel) {
      const grid = channel.dom?.gridEl;
      if (!grid) return;
      grid.innerHTML = '';
      channel.grid.forEach((row, y) => {
        row.forEach((cell, x) => {
          const div = document.createElement('div');
          div.className = 'grid-cell';
        if (cell) {
          div.classList.add('occupied');
          const palette = blockPalette.find(p => p.type === cell.type);
          div.textContent = cell.symbol || palette?.symbol || cell.type[0];
          if (cell.label) {
            const label = document.createElement('div');
            label.className = 'grid-label';
            // Truncate to 8 chars for consistent sizing
            const truncatedLabel = cell.label.length > 8 ? cell.label.slice(0, 7) + '…' : cell.label;
            label.textContent = truncatedLabel.toUpperCase();
            
            // Calculate luminance for contrast
            if (palette?.color) {
              const color = palette.color;
              let r, g, b;
              
              if (color.startsWith('#')) {
                const hex = color.slice(1);
                r = parseInt(hex.slice(0, 2), 16);
                g = parseInt(hex.slice(2, 4), 16);
                b = parseInt(hex.slice(4, 6), 16);
              } else if (color.startsWith('rgb')) {
                const match = color.match(/\d+/g);
                if (match) {
                  [r, g, b] = match.map(Number);
                }
              }
              
              if (r !== undefined && g !== undefined && b !== undefined) {
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                if (luminance > 0.6) {
                  label.classList.add('dark-text');
                } else {
                  label.classList.add('light-text');
                }
              }
            }
            
            div.appendChild(label);
          }
          div.dataset.cellType = cell.type;
          
          // Add hover tooltip with full name
          if (cell.label) {
            div.title = `${cell.label} (${cell.type})\nClick for perspective`;
          } else if (cell.type) {
            div.title = `${cell.type}\nClick for details`;
          }
        }
          div.dataset.x = x;
          div.dataset.y = y;
          div.addEventListener('click', () => {
            focusChannel(channel.id);
            openCellOverlay(channel, x, y);
          });
          grid.appendChild(div);
        });
      });
    }

    function renderChannelMessages(channel) {
      const list = channel.dom && channel.dom.messageList;
      const dotRail = channel.dom && channel.dom.messageDotRail;
      if (!list) return;
      list.innerHTML = '';
      if (dotRail) dotRail.innerHTML = '';
      const lastAssistantId = [...channel.messages].reverse().find(msg => msg.role === 'assistant')?.id || null;
      const totalMessages = channel.messages.length;
      channel.messages.forEach((msg, idx) => {
        const item = document.createElement('div');
        item.className = `message ${msg.role}`;
        item.dataset.messageId = msg.id;

        const isRecent = idx >= totalMessages - 3;
        if (msg.autoCollapse || (!isRecent && msg.role !== 'user')) {
          item.classList.add('collapsed');
        }

        if (channel.forkPoint?.messageId && String(channel.forkPoint.messageId) === String(msg.id)) {
          item.classList.add('fork-origin');
        }

        const header = document.createElement('div');
        header.className = 'message-header';
        
        // Dual-dot visualization for forks (git-style)
        if (channel.parentChannelId) {
          const parentChannel = channelMap.get(channel.parentChannelId);
          if (parentChannel) {
            const parentDot = document.createElement('span');
            parentDot.className = 'message-color-dot parent-dot';
            parentDot.style.color = parentChannel.channelColor;
            parentDot.textContent = '●';
            parentDot.title = `Parent: ${parentChannel.name}`;
            header.appendChild(parentDot);
          }
        }
        
        const colorDot = document.createElement('span');
        colorDot.className = 'message-color-dot';
        if (msg.role === 'user') {
          colorDot.style.color = lightenColor(channel.channelColor, 0.25);
        } else if (msg.role === 'system') {
          colorDot.style.color = lightenColor(channel.channelColor, -0.3);
          colorDot.style.opacity = '0.6';
        } else {
          colorDot.style.color = channel.channelColor;
        }
        colorDot.textContent = '●';
        const origin = msg.fromChannel ? ` ← ${msg.fromChannel}` : '';
        header.appendChild(colorDot);
        const headerText = document.createElement('span');
        const roleDisplay = msg.role === 'tetrad' ? 'TETRAD OPTIONS' : msg.role.toUpperCase();
        headerText.textContent = `${msg.id} · ${roleDisplay}${origin}`;
        header.appendChild(headerText);
        
        // Add ring memory indicator if this message is bound
        if (channel.ringBinding) {
          const ringEntry = ringMemory.entries.find(e => e.id === channel.ringBinding);
          if (ringEntry && msg.role === 'assistant') {
            const ringIndicator = document.createElement('span');
            ringIndicator.className = 'ring-indicator';
            ringIndicator.textContent = '⊚';
            ringIndicator.title = `Bound to ring: ${ringEntry.symbol}`;
            ringIndicator.style.color = channel.channelColor;
            ringIndicator.style.marginLeft = 'auto';
            header.appendChild(ringIndicator);
          }
        }
        
        item.appendChild(header);

        const preview = document.createElement('div');
        preview.className = 'message-preview';
        const msgText = msg.text || '';
        if (msg.role === 'tetrad') {
          preview.textContent = '✨ Tetrad Options Available';
        } else {
          preview.textContent = msgText.split('\n')[0].slice(0, 60) + (msgText.length > 60 ? '…' : '');
        }
        item.appendChild(preview);

        const body = document.createElement('div');
        body.className = 'message-body';
        
        // Special rendering for tetrad messages
        if (msg.role === 'tetrad' && msg.tetradData) {
          // Add reveal animation if this is the latest tetrad
          if (idx === totalMessages - 1) {
            item.style.animation = 'pulse 0.6s ease-in-out';
            item.style.boxShadow = '0 0 20px var(--accent-glow)';
            setTimeout(() => {
              item.style.animation = '';
              item.style.boxShadow = '';
            }, 600);
          }
          
          const tetradMap = [
            { key: 'enhance', icon: '▲', label: 'ENHANCE' },
            { key: 'reverse', icon: '⇄', label: 'REVERSE' },
            { key: 'retrieve', icon: '↺', label: 'RETRIEVE' },
            { key: 'obsolesce', icon: '▼', label: 'OBSOLESCE' }
          ];
          
          tetradMap.forEach((mapping, tetradIdx) => {
            const entry = msg.tetradData[mapping.key];
            if (!entry) return;
            
            const optionDiv = document.createElement('div');
            optionDiv.style.cssText = `
              padding: 10px 12px;
              margin-bottom: 6px;
              border-left: 3px solid var(--accent);
              background: var(--panel-dark);
              transition: all 0.2s var(--transition);
              border-radius: 4px;
              display: flex;
              align-items: flex-start;
              gap: 10px;
              position: relative;
            `;
            
            // Stagger animation for latest tetrad
            if (idx === totalMessages - 1) {
              optionDiv.style.opacity = '0';
              optionDiv.style.transform = 'translateX(-20px)';
              setTimeout(() => {
                optionDiv.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                optionDiv.style.opacity = '1';
                optionDiv.style.transform = 'translateX(0)';
              }, 100 + (tetradIdx * 100));
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.style.cssText = `
              flex: 1;
              cursor: pointer;
            `;
            
            const optionHeader = document.createElement('div');
            optionHeader.style.cssText = `
              font-size: 10px;
              font-weight: 700;
              letter-spacing: 0.15em;
              color: var(--accent);
              margin-bottom: 4px;
            `;
            optionHeader.textContent = `${mapping.icon} ${mapping.label}`;
            
            const optionText = document.createElement('div');
            optionText.style.cssText = `
              font-size: 9px;
              line-height: 1.5;
              color: var(--text);
            `;
            optionText.textContent = entry.text;
            
            contentDiv.appendChild(optionHeader);
            contentDiv.appendChild(optionText);
            
            // Send button (red ball)
            const sendBtn = document.createElement('button');
            sendBtn.style.cssText = `
              width: 32px;
              height: 32px;
              border-radius: 50%;
              background: linear-gradient(135deg, #f87171, #dc2626);
              border: 2px solid #991b1b;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 16px;
              transition: all 0.2s;
              box-shadow: 0 2px 8px rgba(248, 113, 113, 0.4);
              flex-shrink: 0;
            `;
            sendBtn.textContent = '→';
            sendBtn.title = 'Send to input';
            
            optionDiv.appendChild(contentDiv);
            optionDiv.appendChild(sendBtn);
            
            contentDiv.addEventListener('mouseenter', () => {
              optionDiv.style.background = 'var(--accent-soft)';
              optionDiv.style.transform = 'translateX(4px)';
            });
            
            contentDiv.addEventListener('mouseleave', () => {
              optionDiv.style.background = 'var(--panel-dark)';
              optionDiv.style.transform = 'translateX(0)';
            });
            
            sendBtn.addEventListener('mouseenter', () => {
              sendBtn.style.transform = 'scale(1.1)';
              sendBtn.style.boxShadow = '0 4px 16px rgba(248, 113, 113, 0.6)';
            });
            
            sendBtn.addEventListener('mouseleave', () => {
              sendBtn.style.transform = 'scale(1)';
              sendBtn.style.boxShadow = '0 2px 8px rgba(248, 113, 113, 0.4)';
            });
            
            // Click handler for send button
            sendBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const followUpText = `Follow ${mapping.label.toLowerCase()} path: ${entry.text}`;
              channel.dom.input.value = followUpText;
              channel.dom.input.focus();
              
              // Animate the send
              sendBtn.style.transform = 'scale(0.8)';
              sendBtn.style.opacity = '0.5';
              setTimeout(() => {
                sendBtn.style.transform = 'scale(1)';
                sendBtn.style.opacity = '1';
              }, 200);
              
              // Flash effect on option
              optionDiv.style.background = 'var(--accent)';
              optionDiv.style.boxShadow = '0 0 20px var(--accent-glow)';
              setTimeout(() => {
                optionDiv.style.background = 'var(--panel-dark)';
                optionDiv.style.boxShadow = 'none';
              }, 300);
            });
            
            // Click content to preview/read
            contentDiv.addEventListener('click', () => {
              optionDiv.style.background = 'var(--accent-soft)';
            });
            
            body.appendChild(optionDiv);
          });
        } else {
          body.textContent = msgText;
        }
        
        item.appendChild(body);

        if (dotRail) {
          const dot = document.createElement('button');
          dot.className = 'message-dot';
          dot.dataset.messageId = msg.id;
          dot.dataset.role = msg.role;
          dot.dataset.index = idx + 1;
          dot.classList.add(msg.role);
          dot.textContent = String(idx + 1);
          
          // Dual-border for forked channels (git graph style)
          if (channel.parentChannelId) {
            const parentChannel = channelMap.get(channel.parentChannelId);
            if (parentChannel) {
              dot.classList.add('forked-dot');
              dot.style.borderColor = parentChannel.channelColor;
              dot.style.boxShadow = `0 0 0 3px ${channel.channelColor}, 0 0 12px ${channel.channelColor}`;
              dot.title = `${msg.id} · ${msg.role.toUpperCase()} [Fork from ${parentChannel.name}]`;
            }
          } else {
            dot.title = `${msg.id} · ${msg.role.toUpperCase()}`;
          }
          
          if (msg.role === 'user') {
            dot.style.color = lightenColor(channel.channelColor, 0.25);
            dot.style.backgroundColor = lightenColor(channel.channelColor, 0.08);
          } else if (msg.role === 'system') {
            dot.style.color = lightenColor(channel.channelColor, -0.3);
            dot.style.backgroundColor = lightenColor(channel.channelColor, -0.1);
          } else {
            dot.style.color = channel.channelColor;
            dot.style.backgroundColor = lightenColor(channel.channelColor, 0.15);
          }
          if (channel.forkPoint?.messageId && String(channel.forkPoint.messageId) === String(msg.id)) {
            dot.classList.add('fork-origin');
          }
          dot.addEventListener('click', () => {
            activateMessageDot(channel, msg.id);
            item.classList.remove('collapsed');
            item.classList.add('active');
            item.scrollIntoView({ behavior: 'smooth', block: 'center' });
          });
          dotRail.appendChild(dot);
          if (idx === channel.messages.length - 1) {
            dot.classList.add('active');
          }
        }

        if (msg.role === 'assistant') {
          item.addEventListener('click', (event) => {
            if (event.target.closest('.message-actions')) return;
            toggleMessageActions(channel, msg, item);
            document.querySelectorAll(`[data-channel-id="${channel.id}"] .message`).forEach(el => el.classList.remove('active'));
            item.classList.add('active');
            activateMessageDot(channel, msg.id);
          });
          if (msg.id === lastAssistantId && channel.tetrad && Object.keys(channel.tetrad).length) {
            const chips = createTetradChips(channel);
            if (chips) body.appendChild(chips);
          }
        } else {
          item.addEventListener('click', () => {
            item.classList.toggle('collapsed');
            document.querySelectorAll(`[data-channel-id="${channel.id}"] .message`).forEach(el => el.classList.remove('active'));
            if (!item.classList.contains('collapsed')) {
              item.classList.add('active');
              activateMessageDot(channel, msg.id);
            } else if (channel.messages.length) {
              const latest = channel.messages[channel.messages.length - 1];
              if (latest) activateMessageDot(channel, latest.id);
            }
          });
        }

        list.appendChild(item);
      });
      list.scrollTo({ top: list.scrollHeight, behavior: 'smooth' });
      if (channel.messages.length) {
        activateMessageDot(channel, channel.messages[channel.messages.length - 1].id);
      }
    }

    function activateMessageDot(channel, messageId) {
      if (!channel || !channel.dom) return;
      const targetId = String(messageId);
      const { messageDotRail, messageList } = channel.dom;
      if (messageDotRail) {
        messageDotRail.querySelectorAll('.message-dot').forEach(dot => {
          dot.classList.toggle('active', dot.dataset.messageId === targetId);
        });
      }
      if (messageList) {
        messageList.querySelectorAll('.message').forEach(msgEl => {
          if (msgEl.dataset.messageId === targetId) {
            msgEl.classList.add('active');
          } else {
            msgEl.classList.remove('active');
          }
        });
      }
    }

    function toggleMessageActions(channel, message, element) {
      closeAllMenus();
      let menu = element.querySelector('.message-actions');
      if (!menu) {
        menu = document.createElement('div');
        menu.className = 'message-actions';
        
        const closeBtn = document.createElement('button');
        closeBtn.className = 'message-action-close';
        closeBtn.textContent = '✕';
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          closeAllMenus();
        });
        menu.appendChild(closeBtn);
        
        const options = buildMessageOptions(channel, message);
        options.forEach(opt => menu.appendChild(opt));
        element.appendChild(menu);
      }
      menu.classList.toggle('active');
    }

    function closeAllMenus() {
      document.querySelectorAll('.message-actions.active').forEach(menu => menu.classList.remove('active'));
    }
    
    function sendPerspectiveToChat(channel, text) {
      if (!channel || !channel.dom) return;
      const textarea = channel.dom.input;
      if (textarea) {
        // Add to existing text or set new text
        const currentText = textarea.value.trim();
        textarea.value = currentText ? `${currentText}\n\n${text}` : text;
        textarea.style.height = 'auto';
        textarea.style.height = textarea.scrollHeight + 'px';
        textarea.focus();
        
        // Close perspective overlay
        document.getElementById('perspectiveOverlay').classList.remove('active');
        
        // Show feedback
        const feedback = document.createElement('div');
        feedback.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: var(--accent);
          color: var(--bg);
          padding: 12px 20px;
          border-radius: 4px;
          font-size: 11px;
          font-weight: 700;
          letter-spacing: 0.1em;
          z-index: 10000;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          animation: slideInRight 0.3s ease;
        `;
        feedback.textContent = 'SENT TO CHAT';
        document.body.appendChild(feedback);
        setTimeout(() => {
          feedback.style.opacity = '0';
          feedback.style.transform = 'translateX(20px)';
          setTimeout(() => feedback.remove(), 300);
        }, 1500);
      }
    }

    function buildMessageOptions(channel, message) {
      // Auto-generate tetrad if missing and scene exists
      if (channel.lastScene && !channel.tetrad && !channel.pendingTetrad && appState.apiKey) {
        regenerateTetrad(channel);
      }
      
      const fragments = [];
      const addOption = (label, handler, enabled = true) => {
        const div = document.createElement('div');
        div.className = 'message-action';
        div.textContent = label;
        if (enabled) {
          div.addEventListener('click', (e) => {
            e.stopPropagation();
            closeAllMenus();
            handler();
          });
        } else {
          div.classList.add('disabled');
        }
        fragments.push(div);
      };

      addOption('↔ FORK: CONTINUE', () => forkChannel(channel, message, 'continue'));

      ['enhance', 'reverse', 'retrieve', 'obsolesce'].forEach(key => {
        const entry = channel.tetrad?.[key];
        const label = `⋔ FORK: ${key.toUpperCase()}`;
        // Always enable if we have a scene (tetrad will generate)
        const enabled = Boolean(channel.lastScene);
        addOption(label, () => {
          if (!entry?.text) {
            // If no tetrad yet, generate it first
            if (channel.lastScene && !channel.pendingTetrad) {
              regenerateTetrad(channel).then(() => {
                // Try to fork again after generation
                const newEntry = channel.tetrad?.[key];
                if (newEntry?.text) {
                  forkChannel(channel, message, key);
                }
              });
            }
            return;
          }
          forkChannel(channel, message, key);
        }, enabled);
      });

      addOption('◎ FORK: PERSPECTIVE', () => forkChannel(channel, message, 'perspective'));
      addOption('⧉ FORK: SNAPSHOT', () => forkChannel(channel, message, 'snapshot'));
      addOption('+ NEW BLANK CHANNEL', () => forkChannel(channel, message, 'blank'));

      const otherChannels = appState.channels.filter(ch => ch.id !== channel.id);
      if (otherChannels.length) {
        otherChannels.forEach(target => {
          addOption(`→ SEND TO ${target.name}`, () => routeMessage(channel, target, message));
        });
      }

      return fragments;
    }

    // Normalize tetrad data from any format to standard {enhance, reverse, retrieve, obsolesce}
    function normalizeTetradData(channel) {
      if (!channel.tetrad) return null;
      
      // Format 1: Direct object with keys {enhance: {...}, reverse: {...}, ...}
      if (typeof channel.tetrad === 'object' && !Array.isArray(channel.tetrad)) {
        if (channel.tetrad.enhance) return channel.tetrad; // ✅ Already correct!
        if (channel.tetrad.tetradEntries) return null; // ❌ Old format, ignore
        
        // Check if it's wrapped like {tetrad: {enhance: {...}}}
        if (channel.tetrad.tetrad && typeof channel.tetrad.tetrad === 'object') {
          return normalizeTetradData({tetrad: channel.tetrad.tetrad}); // Unwrap and retry
        }
      }
      
      // Format 2: tetrads array (get latest)
      if (channel.tetrads && Array.isArray(channel.tetrads) && channel.tetrads.length > 0) {
        const latest = channel.tetrads[channel.tetrads.length - 1];
        if (latest && latest.enhance) return latest;
      }
      
      // Format 3: tetrad as array with type property [{type: 'enhance', ...}, ...]
      if (Array.isArray(channel.tetrad) && channel.tetrad.length > 0) {
        const result = {};
        channel.tetrad.forEach(item => {
          if (item && item.type && item.text) {
            result[item.type] = {text: item.text, score: item.score || 0};
          }
        });
        if (Object.keys(result).length > 0) {
          console.log('[TETRAD] Converted array format:', result);
          return result; // ✅ Converted!
        }
      }
      
      console.log('[TETRAD] Unknown format:', channel.tetrad);
      return null;
    }
    
    // Create tetrad chips inline in message (like tet-chat.html)
    function createTetradChipsInline(channel) {
      const tetradData = normalizeTetradData(channel);
      if (!tetradData) return null;
      
      const container = document.createElement('div');
      container.className = 'tetrad-chips-inline';
      container.style.cssText = `
        margin-top: 12px;
        padding: 12px;
        background: rgba(0, 0, 0, 0.3);
        border-left: 3px solid var(--accent);
        border-radius: 4px;
      `;
      
      // Add header
      const header = document.createElement('div');
      header.style.cssText = `
        font-size: 9px;
        font-weight: 700;
        letter-spacing: 0.15em;
        color: var(--accent);
        margin-bottom: 8px;
        text-transform: uppercase;
      `;
      header.innerHTML = `
        <span>⋔ TETRAD OPTIONS — Click to use</span>
        <button id="tetrad-perspective-toggle-${channel.id}" style="
          margin-left: auto;
          padding: 4px 8px;
          font-size: 8px;
          background: ${channel.tetradPerspective ? 'var(--accent)' : 'var(--panel-dark)'};
          color: ${channel.tetradPerspective ? 'var(--bg)' : 'var(--text)'};
          border: 1px solid ${channel.tetradPerspective ? 'var(--accent)' : 'var(--border)'};
          border-radius: 3px;
          cursor: pointer;
          font-weight: 700;
          letter-spacing: 0.05em;
        ">
          ${channel.tetradPerspective ? '👁 ' + channel.tetradPerspective : '👁 SET PERSPECTIVE'}
        </button>
      `;
      
      // Add perspective toggle handler
      setTimeout(() => {
        const toggleBtn = document.getElementById(`tetrad-perspective-toggle-${channel.id}`);
        if (toggleBtn) {
          toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            openPerspectiveSelector(channel);
          });
        }
      }, 0);
      
      container.appendChild(header);
      
      // Create chips container
      const chipsWrap = document.createElement('div');
      chipsWrap.style.cssText = `
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      `;
      
      console.log('[TETRAD] Creating chips for channel:', channel.id, 'Data:', tetradData);
      
      const tetradMap = [
        { key: 'enhance', icon: '⋔', label: 'ENHANCE' },
        { key: 'reverse', icon: '⋔', label: 'REVERSE' },
        { key: 'retrieve', icon: '⋔', label: 'RETRIEVE' },
        { key: 'obsolesce', icon: '⋔', label: 'OBSOLESCE' }
      ];
      
      let hasChips = false;
      tetradMap.forEach(mapping => {
        const entry = tetradData[mapping.key];
        if (!entry || !entry.text) return;
        
        hasChips = true;
        const chip = document.createElement('div');
        chip.className = 'tetrad-chip-inline';
        chip.style.cssText = `
          flex: 1;
          min-width: 140px;
          padding: 8px 10px;
          background: var(--panel-dark);
          border: 1px solid var(--border);
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s;
          display: flex;
          align-items: center;
          gap: 6px;
        `;
        
        const previewText = entry.text.substring(0, 50) + (entry.text.length > 50 ? '...' : '');
        chip.innerHTML = `
          <div style="display: flex; flex-direction: column; gap: 4px; width: 100%;">
            <div style="display: flex; align-items: center; gap: 6px;">
              <span style="font-size: 12px;">${mapping.icon}</span>
              <span style="font-size: 8px; font-weight: 700; text-transform: uppercase; opacity: 0.8; letter-spacing: 0.1em;">${mapping.label}</span>
              <span style="margin-left: auto; font-size: 8px; opacity: 0.6;">${entry.score || 0}</span>
            </div>
            <div style="font-size: 9px; opacity: 0.7; line-height: 1.3;">${previewText}</div>
          </div>
        `;
        chip.title = entry.text;
        
        chip.addEventListener('click', (e) => {
          e.stopPropagation();
          console.log('[TETRAD] Chip clicked:', mapping.key, entry.text);
          const textarea = channel.dom?.input;
          if (textarea) {
            textarea.value = entry.text;
            textarea.focus();
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
          }
        });
        
        chip.addEventListener('mouseenter', () => {
          chip.style.background = 'var(--accent)';
          chip.style.color = 'var(--bg)';
          chip.style.borderColor = 'var(--accent)';
        });
        
        chip.addEventListener('mouseleave', () => {
          chip.style.background = 'var(--panel-dark)';
          chip.style.color = '';
          chip.style.borderColor = 'var(--border)';
        });
        
        chipsWrap.appendChild(chip);
      });
      
      if (hasChips) {
        container.appendChild(chipsWrap);
        return container;
      }
      return null;
    }
    
    function createTetradChips(channel) {
      const tetradData = normalizeTetradData(channel);
      if (!tetradData) return null;
      
      const container = document.createElement('div');
      container.style.display = 'flex';
      container.style.flexWrap = 'wrap';
      container.style.gap = '6px';
      container.style.marginTop = '12px';
      ['enhance', 'reverse', 'retrieve', 'obsolesce'].forEach(key => {
        const entry = tetradData[key];
        if (!entry) return;
        const chip = document.createElement('button');
        chip.className = `tetrad-chip ${key}`;
        chip.textContent = key.toUpperCase();
        chip.title = entry.text;
        chip.addEventListener('click', (event) => {
          event.stopPropagation();
          chip.style.transform = 'scale(0.95)';
          setTimeout(() => chip.style.transform = '', 100);
          addMessageToChannel(channel, 'user', entry.text);
          if (appState.apiKey) {
            composeScene(channel, entry.text);
          } else {
            addMessageToChannel(channel, 'system', 'API key required for scene assembly.');
          }
        });
        container.appendChild(chip);
      });
      return container;
    }

    function addMessageToChannel(channel, role, text, extra = {}) {
      channel.addMessage(role, text, extra);
      renderChannelMessages(channel);
      persistState();
    }

    function renderTetradPanel(channel) {
      const tetradData = normalizeTetradData(channel);
      if (!tetradData) return;
      
      // Add tetrad as a special message type
      const tetradMessage = {
        role: 'tetrad',
        text: '', // Will be rendered specially
        tetradData: tetradData,
        timestamp: Date.now(),
        id: `tetrad-${Date.now()}`
      };
      
      // Check if last message is already a tetrad, replace it
      const lastMsg = channel.messages[channel.messages.length - 1];
      if (lastMsg && lastMsg.role === 'tetrad') {
        channel.messages[channel.messages.length - 1] = tetradMessage;
      } else {
        channel.messages.push(tetradMessage);
      }
      
      // Re-render messages to show tetrad
      renderChannelMessages(channel);
      persistState();
    }

    function openPerspectiveSelector(channel) {
      // Get all entities from the grid
      const entities = [];
      channel.grid.forEach((row, y) => {
        row.forEach((cell, x) => {
          if (cell && cell.type === 'Entity' && cell.label) {
            entities.push({label: cell.label, x, y, entity: cell.entity});
          }
        });
      });
      
      if (entities.length === 0) {
        addMessageToChannel(channel, 'system', 'No entities on grid. Add entities first to set perspective.');
        return;
      }
      
      // Create modal
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(90vw, 400px);
        max-height: 80vh;
        background: var(--panel);
        border: 2px solid var(--accent);
        border-radius: 8px;
        padding: 20px;
        z-index: 300;
        box-shadow: 0 20px 60px rgba(0,0,0,0.8);
        overflow-y: auto;
      `;
      
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        backdrop-filter: blur(4px);
        z-index: 299;
      `;
      
      modal.innerHTML = `
        <h2 style="font-size: 14px; letter-spacing: 0.2em; color: var(--accent); margin-bottom: 16px; text-transform: uppercase;">
          👁 SELECT PERSPECTIVE
        </h2>
        <p style="font-size: 10px; color: var(--text-muted); margin-bottom: 16px; line-height: 1.5;">
          Choose an entity's perspective for tetrad generation. The tetrad will be generated from their point of view.
        </p>
        <div id="entity-list" style="display: grid; gap: 8px;"></div>
        <div style="margin-top: 16px; display: flex; gap: 8px;">
          <button id="clear-perspective" style="flex: 1; padding: 10px; background: var(--panel-dark); border: 1px solid var(--border); border-radius: 4px; cursor: pointer; font-size: 10px; text-transform: uppercase; letter-spacing: 0.1em;">
            CLEAR
          </button>
          <button id="close-perspective" style="flex: 1; padding: 10px; background: var(--accent); color: var(--bg); border: none; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em;">
            CLOSE
          </button>
        </div>
      `;
      
      const entityList = modal.querySelector('#entity-list');
      entities.forEach(ent => {
        const btn = document.createElement('button');
        btn.style.cssText = `
          padding: 12px;
          background: ${channel.tetradPerspective === ent.label ? 'var(--accent)' : 'var(--panel-dark)'};
          color: ${channel.tetradPerspective === ent.label ? 'var(--bg)' : 'var(--text)'};
          border: 2px solid ${channel.tetradPerspective === ent.label ? 'var(--accent)' : 'var(--border)'};
          border-radius: 6px;
          cursor: pointer;
          text-align: left;
          font-size: 11px;
          font-weight: ${channel.tetradPerspective === ent.label ? '700' : '400'};
          transition: all 0.2s;
        `;
        
        btn.innerHTML = `
          <div style="font-weight: 700; margin-bottom: 4px;">${ent.label.toUpperCase()}</div>
          <div style="font-size: 9px; opacity: 0.7;">Position: (${ent.x}, ${ent.y})</div>
        `;
        
        btn.addEventListener('click', async () => {
          // Flash selected button
          btn.style.background = 'var(--accent)';
          btn.style.transform = 'scale(1.05)';
          btn.style.boxShadow = '0 0 20px var(--accent-glow)';
          
          setTimeout(() => {
            channel.tetradPerspective = ent.label;
            modal.remove();
            backdrop.remove();
            
            // Show visual feedback on grid
            const gridCell = channel.dom.gridEl?.querySelector(`[data-x="${ent.x}"][data-y="${ent.y}"]`);
            if (gridCell) {
              gridCell.style.animation = 'pulse 1s ease-in-out 3';
              gridCell.style.boxShadow = '0 0 30px var(--accent-glow)';
              setTimeout(() => {
                gridCell.style.animation = '';
                gridCell.style.boxShadow = '';
              }, 3000);
            }
            
            // Regenerate tetrad from this perspective
            if (channel.lastScene) {
              regenerateTetrad(channel);
            }
            
            // Re-render messages to update button
            renderChannelMessages(channel);
          }, 200);
        });
        
        btn.addEventListener('mouseenter', () => {
          if (channel.tetradPerspective !== ent.label) {
            btn.style.background = 'var(--border)';
          }
        });
        
        btn.addEventListener('mouseleave', () => {
          if (channel.tetradPerspective !== ent.label) {
            btn.style.background = 'var(--panel-dark)';
          }
        });
        
        entityList.appendChild(btn);
      });
      
      modal.querySelector('#clear-perspective').addEventListener('click', () => {
        channel.tetradPerspective = null;
        modal.remove();
        backdrop.remove();
        renderChannelMessages(channel);
      });
      
      modal.querySelector('#close-perspective').addEventListener('click', () => {
        modal.remove();
        backdrop.remove();
      });
      
      backdrop.addEventListener('click', () => {
        modal.remove();
        backdrop.remove();
      });
      
      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
    }
    
    async function regenerateTetrad(channel) {
      if (channel.pendingTetrad) return;
      if (!channel.lastScene) {
        addMessageToChannel(channel, 'system', 'Compose a scene before requesting tetrad options.');
        return;
      }
      try {
        channel.pendingTetrad = true;
        
        // Show loading message
        addMessageToChannel(channel, 'system', `✨ Generating tetrad ${channel.tetradPerspective ? `from ${channel.tetradPerspective}'s perspective` : 'options'}...`);
        
        // Animate grid during regeneration
        const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
        gridCells?.forEach((cell, idx) => {
          cell.style.animation = `pulse 1.5s ease-in-out infinite`;
          cell.style.animationDelay = `${(idx * 0.03) % 0.5}s`;
        });
        
        renderTetradPanel(channel);
        const tetrad = await callOpenAI('TetradGenerator', {
          scenario: scenarios[channel.scenario],
          scene: channel.lastScene,
          history: channel.messages.slice(-2).map(m => ({ role: m.role, text: m.text })),
          perspective: channel.tetradPerspective || null
        });
        channel.tetrad = tetrad;
        persistState();
        
        // Stop animation
        gridCells?.forEach((cell) => {
          cell.style.animation = '';
        });
        
        // Flash effect
        channel.dom.column?.classList.add('reveal');
        setTimeout(() => channel.dom.column?.classList.remove('reveal'), 500);
        
        // Re-render messages to show tetrad
        renderChannelMessages(channel);
        playRevealChime();
      } catch (err) {
        addMessageToChannel(channel, 'system', `Tetrad generation failed: ${err.message}`);
        // Stop animation on error
        const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
        gridCells?.forEach((cell) => {
          cell.style.animation = '';
        });
      } finally {
        channel.pendingTetrad = false;
        renderTetradPanel(channel);
      }
    }

    function openTetradMenu(channel) {
      // Disabled - tetrad chips now appear inline in messages only
      return;
      
      const tetradData = normalizeTetradData(channel);
      
      if (!tetradData) {
        if (!channel.lastScene) {
          addMessageToChannel(channel, 'system', 'Compose a scene first to unlock tetrad options.');
          return;
        }
        // Auto-generate if not present
        regenerateTetrad(channel);
        return;
      }
      
      const modal = document.createElement('div');
      modal.className = 'tetrad-menu-modal';
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(90vw, 400px);
        background: var(--panel);
        border: 2px solid var(--accent);
        border-radius: 8px;
        padding: 24px;
        z-index: 300;
        box-shadow: 0 20px 60px rgba(0,0,0,0.8);
      `;
      
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        backdrop-filter: blur(4px);
        z-index: 299;
      `;
      
      const header = document.createElement('div');
      header.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;';
      header.innerHTML = `
        <h2 style="font-size: 14px; letter-spacing: 0.2em; color: var(--accent);">TETRAD TRAJECTORIES</h2>
        <button style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border); background: var(--panel-dark); color: var(--text); cursor: pointer;" onclick="this.closest('.tetrad-menu-modal').remove(); document.querySelectorAll('[style*=backdrop-filter]')[0]?.remove();">×</button>
      `;
      
      const grid = document.createElement('div');
      grid.style.cssText = 'display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;';
      
      const tetradMap = [
        { key: 'enhance', icon: '▲', label: 'ENHANCE' },
        { key: 'reverse', icon: '⇄', label: 'REVERSE' },
        { key: 'retrieve', icon: '↺', label: 'RETRIEVE' },
        { key: 'obsolesce', icon: '▼', label: 'OBSOLESCE' }
      ];
      
      console.log('[TETRAD MENU] Opening with data:', tetradData);
      
      tetradMap.forEach(mapping => {
        const entry = tetradData[mapping.key];
        if (!entry) {
          console.log('[TETRAD MENU] Missing entry for:', mapping.key);
          return;
        }
        
        const btn = document.createElement('button');
        btn.style.cssText = `
          padding: 20px;
          background: var(--panel-dark);
          border: 3px solid var(--border);
          border-radius: 8px;
          cursor: pointer;
          transition: all 0.2s var(--transition);
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 12px;
          box-shadow: 0 2px 0 var(--border), inset 0 1px 0 rgba(255,255,255,0.1);
        `;
        
        btn.innerHTML = `
          <div style="font-size: 32px; color: var(--accent);">${mapping.icon}</div>
          <div style="font-size: 10px; letter-spacing: 0.2em; color: var(--text); font-weight: bold;">${mapping.label}</div>
          <div style="font-size: 8px; color: var(--text-muted); text-align: center; line-height: 1.4; max-height: 60px; overflow: hidden;">${entry.text.substring(0, 80)}...</div>
        `;
        
        btn.addEventListener('mouseenter', () => {
          btn.style.background = 'var(--accent)';
          btn.style.color = 'var(--bg)';
          btn.style.transform = 'scale(1.02)';
        });
        
        btn.addEventListener('mouseleave', () => {
          btn.style.background = 'var(--panel-dark)';
          btn.style.color = '';
          btn.style.transform = '';
        });
        
        btn.addEventListener('click', async () => {
          btn.style.transform = 'scale(0.95) translateY(2px)';
          btn.style.boxShadow = '0 0 0 var(--border)';
          
          modal.remove();
          backdrop.remove();
          
          addMessageToChannel(channel, 'user', entry.text);
          if (appState.apiKey) {
            await composeScene(channel, entry.text);
          } else {
            addMessageToChannel(channel, 'system', 'API key required for scene assembly.');
          }
        });
        
        grid.appendChild(btn);
      });
      
      modal.appendChild(header);
      modal.appendChild(grid);
      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
      
      backdrop.addEventListener('click', () => {
        modal.remove();
        backdrop.remove();
      });
    }

    function openRingOverview(channel) {
      const modal = document.createElement('div');
      modal.className = 'ring-overview-modal';
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(90vw, 600px);
        max-height: 80vh;
        background: var(--panel);
        border: 2px solid var(--accent);
        border-radius: 8px;
        padding: 24px;
        z-index: 300;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0,0,0,0.8);
      `;
      
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        backdrop-filter: blur(4px);
        z-index: 299;
      `;
      
      const header = document.createElement('div');
      header.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;';
      
      const title = document.createElement('h2');
      title.style.cssText = 'font-size: 14px; letter-spacing: 0.2em; color: var(--accent);';
      title.textContent = 'RING MEMORY TIMELINE';
      
      const controls = document.createElement('div');
      controls.style.cssText = 'display: flex; gap: 8px; align-items: center;';
      
      const exportBtn = document.createElement('button');
      exportBtn.style.cssText = `
        padding: 6px 12px;
        border-radius: 4px;
        border: 1px solid var(--accent);
        background: var(--panel-dark);
        color: var(--accent);
        cursor: pointer;
        font-size: 9px;
        letter-spacing: 0.1em;
        transition: all 0.2s;
      `;
      exportBtn.textContent = 'EXPORT';
      exportBtn.addEventListener('click', () => {
        const data = {
          exported: new Date().toISOString(),
          ringMemory: ringMemory,
          channels: appState.channels.map(ch => ({
            id: ch.id,
            name: ch.name,
            scenario: ch.scenario,
            channelColor: ch.channelColor,
            ledgerCount: ch.ledger?.length || 0
          }))
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `legos-ring-memory-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      });
      exportBtn.addEventListener('mouseenter', () => {
        exportBtn.style.background = 'var(--accent)';
        exportBtn.style.color = 'var(--bg)';
      });
      exportBtn.addEventListener('mouseleave', () => {
        exportBtn.style.background = 'var(--panel-dark)';
        exportBtn.style.color = 'var(--accent)';
      });
      
      const closeBtn = document.createElement('button');
      closeBtn.style.cssText = 'width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border); background: var(--panel-dark); color: var(--text); cursor: pointer;';
      closeBtn.textContent = '×';
      closeBtn.addEventListener('click', () => {
        modal.remove();
        backdrop.remove();
      });
      
      controls.appendChild(exportBtn);
      controls.appendChild(closeBtn);
      header.appendChild(title);
      header.appendChild(controls);
      
      const content = document.createElement('div');
      content.style.cssText = 'display: flex; flex-direction: column; gap: 12px;';
      
      if (ringMemory.entries.length === 0) {
        content.innerHTML = '<p style="color: var(--text-muted); text-align: center;">No ring memory entries yet. Compose scenes to build your timeline.</p>';
      } else {
        ringMemory.entries.forEach((entry, idx) => {
          const item = document.createElement('div');
          item.style.cssText = `
            padding: 16px;
            background: ${entry.channelId === channel.id ? 'var(--accent-soft)' : 'var(--panel-dark)'};
            border: 1px solid ${entry.isMainline ? 'var(--accent)' : 'var(--border)'};
            border-left: 4px solid ${channelMap.get(entry.channelId)?.channelColor || 'var(--accent)'};
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s var(--transition);
          `;
          
          item.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <span style="font-size: 10px; letter-spacing: 0.2em; color: var(--text-muted);">${entry.symbol} ${entry.isMainline ? '(MAINLINE)' : ''}</span>
              <span style="font-size: 8px; color: var(--text-muted);">${new Date(entry.timestamp).toLocaleTimeString()}</span>
            </div>
            <div style="font-size: 12px; font-weight: bold; color: var(--text); margin-bottom: 6px;">${entry.headline || 'Untitled'}</div>
            <div style="font-size: 10px; color: var(--text-muted); line-height: 1.5;">${(entry.summary || '').substring(0, 120)}${entry.summary?.length > 120 ? '...' : ''}</div>
          `;
          
          item.addEventListener('click', () => {
            const targetChannel = channelMap.get(entry.channelId);
            if (targetChannel) {
              focusChannel(entry.channelId);
              modal.remove();
              backdrop.remove();
            }
          });
          
          item.addEventListener('mouseenter', () => {
            item.style.background = 'var(--accent-soft)';
            item.style.transform = 'translateX(4px)';
          });
          
          item.addEventListener('mouseleave', () => {
            item.style.background = entry.channelId === channel.id ? 'var(--accent-soft)' : 'var(--panel-dark)';
            item.style.transform = 'translateX(0)';
          });
          
          content.appendChild(item);
        });
      }
      
      modal.appendChild(header);
      modal.appendChild(content);
      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
      
      backdrop.addEventListener('click', () => {
        modal.remove();
        backdrop.remove();
      });
    }

    function openSnapshotOverlay(channel) {
      snapshotOverlayChannel = channel;
      renderSnapshotOverlay();
      document.querySelectorAll('.corner-menu.visible').forEach(menu => menu.classList.remove('visible'));
      const overlay = document.getElementById('snapshotOverlay');
      if (overlay) overlay.classList.add('active');
    }

    function renderSnapshotOverlay() {
      const overlay = document.getElementById('snapshotOverlay');
      if (!overlay || !snapshotOverlayChannel) return;
      const list = document.getElementById('snapshotOverlayList');
      const status = document.getElementById('snapshotStatus');
      const snapshots = snapshotOverlayChannel.snapshots || [];
      status.textContent = snapshots.length
        ? `${snapshots.length} saved state${snapshots.length === 1 ? '' : 's'}.`
        : 'No snapshots saved yet.';
      list.innerHTML = '';
      snapshots.slice().reverse().forEach(snapshot => {
        const item = document.createElement('div');
        item.className = 'snapshot-overlay-item';

        const meta = document.createElement('div');
        meta.className = 'snapshot-overlay-meta';
        const label = document.createElement('span');
        label.textContent = snapshot.name.toUpperCase();
        const time = document.createElement('span');
        time.textContent = new Date(snapshot.timestamp).toLocaleString();
        meta.appendChild(label);
        meta.appendChild(time);
        item.appendChild(meta);

        const info = document.createElement('div');
        info.className = 'overlay-value';
        const title = snapshot.lastScene?.sceneTitle ? `Last: ${snapshot.lastScene.sceneTitle}` : 'Last: —';
        info.textContent = `${snapshot.ledgerLength || 0} scenes captured • ${title}`;
        item.appendChild(info);

        const actions = document.createElement('div');
        actions.className = 'snapshot-overlay-actions';
        const loadBtn = document.createElement('button');
        loadBtn.className = 'secondary-btn';
        loadBtn.textContent = 'LOAD';
        loadBtn.addEventListener('click', () => {
          loadSnapshot(snapshotOverlayChannel, snapshot.id);
          document.getElementById('snapshotOverlay').classList.remove('active');
          snapshotOverlayChannel = null;
        });
        const forkBtn = document.createElement('button');
        forkBtn.className = 'primary-btn';
        forkBtn.textContent = 'FORK';
        forkBtn.addEventListener('click', () => {
          const baseMessage = snapshotOverlayChannel.messages[snapshotOverlayChannel.messages.length - 1] || { id: null };
          forkChannel(snapshotOverlayChannel, baseMessage, 'snapshot', { snapshotId: snapshot.id });
          document.getElementById('snapshotOverlay').classList.remove('active');
          snapshotOverlayChannel = null;
        });
        actions.appendChild(loadBtn);
        actions.appendChild(forkBtn);
        item.appendChild(actions);

        list.appendChild(item);
      });
    }

    const snapshotOverlayElement = document.getElementById('snapshotOverlay');
    const snapshotCreateBtn = document.getElementById('snapshotCreateBtn');
    if (snapshotOverlayElement) {
      snapshotOverlayElement.addEventListener('click', (event) => {
        if (event.target === snapshotOverlayElement) {
          snapshotOverlayElement.classList.remove('active');
          snapshotOverlayChannel = null;
        }
      });
      const snapshotCard = snapshotOverlayElement.querySelector('.overlay-card');
      if (snapshotCard) {
        snapshotCard.addEventListener('click', (event) => event.stopPropagation());
      }
    }

    if (snapshotCreateBtn) {
      snapshotCreateBtn.addEventListener('click', () => {
        if (!snapshotOverlayChannel) return;
        const nextIndex = snapshotOverlayChannel.snapshots.length + 1;
        const label = window.prompt('Snapshot name?', `Snapshot ${nextIndex}`);
        if (label === null) return;
        const snap = snapshotOverlayChannel.createSnapshot(label.trim() || `Snapshot ${nextIndex}`);
        logRingEntry({
          type: 'snapshot',
          channelId: snapshotOverlayChannel.id,
          channelName: snapshotOverlayChannel.name,
          symbol: snap.name,
          headline: 'Snapshot saved',
          summary: `${snap.ledgerLength || 0} scenes captured`
        });
        renderSnapshotOverlay();
        persistState();
        showHelpBanner(`Snapshot saved: ${snap.name}`);
      });
    }


    function loadSnapshot(channel, snapshotId) {
      const snap = channel.snapshots.find(s => s.id === snapshotId);
      if (!snap) return;
      channel.grid = deepClone(snap.grid);
      channel.cells = deepClone(snap.cells);
      channel.observer = deepClone(snap.observer);
      channel.scorecard = deepClone(snap.scorecard);
      channel.tetrad = deepClone(snap.tetrad);
      channel.lastScene = deepClone(snap.lastScene);
      renderChannel(channel);
      persistState();
      showHelpBanner(`Snapshot loaded into ${channel.name}`);
      if (snapshotOverlayChannel === channel) {
        renderSnapshotOverlay();
      }
    }

    function renderTimeline() {
      appState.channels.forEach((channel, channelIdx) => {
        const rail = channel.dom?.channelRail;
        if (!rail) return;
        rail.innerHTML = '';
        
        // Show all channel numbers (scrollable list)
        appState.channels.forEach((target, idx) => {
          const button = document.createElement('button');
          button.className = 'channel-number';
          button.textContent = idx + 1;
          button.title = target.name;
          button.style.borderColor = target.channelColor;
          button.style.color = target.channelColor;
          
          // Each channel shows ITS OWN number lit up
          if (target.id === channel.id) {
            // This is the channel's own number - LIGHT IT UP
            button.classList.add('active');
            button.style.backgroundColor = target.channelColor;
            button.style.color = getComputedStyle(document.body).getPropertyValue('--bg');
            button.style.opacity = '1';
          } else {
            // Other channels - visible and ready
            button.style.opacity = '0.7';
          }
          
          button.addEventListener('click', (event) => {
            event.stopPropagation();
            focusChannel(target.id);
          });
          rail.appendChild(button);
        });
        const add = document.createElement('button');
        add.className = 'channel-number add';
        add.textContent = '+';
        add.title = 'Add channel';
        add.style.borderColor = getComputedStyle(document.body).getPropertyValue('--accent');
        add.style.color = getComputedStyle(document.body).getPropertyValue('--accent');
        add.addEventListener('click', (event) => {
          event.stopPropagation();
          const created = createChannel({ scenario: 'blank' });
          focusChannel(created.id);
        });
        rail.appendChild(add);
      });
    }

    function animateChannelTransition(fromChannel, toChannel) {
      const fromEl = fromChannel.dom?.column;
      const toEl = toChannel.dom?.column;
      if (!fromEl || !toEl) return;
      
      const fromRect = fromEl.getBoundingClientRect();
      const toRect = toEl.getBoundingClientRect();
      
      const ball = document.createElement('div');
      ball.style.cssText = `
        position: fixed;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: ${fromChannel.channelColor};
        border: 3px solid ${toChannel.channelColor};
        box-shadow: 0 0 20px ${fromChannel.channelColor}, inset 0 0 10px ${toChannel.channelColor};
        z-index: 1000;
        pointer-events: none;
        left: ${fromRect.left + fromRect.width / 2 - 12}px;
        top: ${fromRect.top + fromRect.height / 2 - 12}px;
        transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      `;
      
      document.body.appendChild(ball);
      
      requestAnimationFrame(() => {
        ball.style.left = `${toRect.left + toRect.width / 2 - 12}px`;
        ball.style.top = `${toRect.top + toRect.height / 2 - 12}px`;
        ball.style.transform = 'scale(1.5)';
        ball.style.opacity = '0.8';
      });
      
      setTimeout(() => {
        ball.style.opacity = '0';
        ball.style.transform = 'scale(0.5)';
        setTimeout(() => ball.remove(), 300);
      }, 800);
    }

    function focusChannel(channelId) {
      // Set as current
      appState.currentChannelId = channelId;
      
      // Get the channel element
      const element = document.querySelector(`[data-channel-id="${channelId}"]`);
      if (!element) return;
      
      // Scroll to it NOW - smooth and to the left edge
      const scroller = document.getElementById('channelScroller');
      if (scroller) {
        scroller.scrollTo({
          left: element.offsetLeft,
          behavior: 'smooth'
        });
      }
      
      // Remove active from all
      document.querySelectorAll('.channel-column').forEach(col => {
        col.classList.remove('channel-active');
      });
      
      // Add active to this one
      element.classList.add('channel-active');
      
      // Update timeline to show which number is lit
      renderTimeline();
      
      // Get active channel and scroll its number to top
      const activeChannel = appState.channels.find(ch => ch.id === channelId);
      const channelIndex = appState.channels.findIndex(ch => ch.id === channelId);
      
      // If page is bright, scroll its number to the top
      if (activeChannel?.dom?.channelRail && channelIndex !== -1) {
        setTimeout(() => {
          const rail = activeChannel.dom.channelRail;
          const buttons = Array.from(rail.querySelectorAll('.channel-number'));
          const activeButton = buttons[channelIndex];
          if (activeButton) {
            activeButton.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, 100);
      }
      
      // Update global scenario
      const globalScenarioSelect = document.getElementById('globalScenarioSelect');
      if (activeChannel && globalScenarioSelect) {
        globalScenarioSelect.value = activeChannel.scenario;
      }
      
      persistState();
    }

    function refreshAllChannels() {
      appState.channels.forEach(channel => renderChannel(channel));
    }
    
    function setupChannelVisibilityObserver() {
      const scroller = document.querySelector('.channel-scroller');
      if (!scroller) return;
      
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
            const channelId = entry.target.dataset.channelId;
            if (channelId && channelId !== appState.currentChannelId) {
              appState.currentChannelId = channelId;
              renderTimeline();
              
              // Update active channel highlighting
              document.querySelectorAll('.channel-column').forEach(col => {
                col.classList.remove('channel-active');
              });
              entry.target.classList.add('channel-active');
            }
          }
        });
      }, {
        root: scroller,
        threshold: 0.5
      });
      
      document.querySelectorAll('.channel-column[data-channel-id]').forEach(col => {
        observer.observe(col);
      });
    }

    async function composeScene(channel, message) {
      if (channel.pending) return;
      channel.pending = true;
      channel.dom.sendBtn.disabled = true;
      channel.dom.column.classList.add('composing');
      const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
      // Use the user's actual prompt text for animation!
      const composeText = (message || '').toUpperCase().replace(/[^A-Z0-9\s]/g, '').replace(/\s+/g, '');
      const entropy = []; // Collect entropy from random walks
      
      console.log('[ANIMATION] Using prompt text:', composeText);
      
      gridCells?.forEach((cell, idx) => {
        cell.classList.add('loading');
        cell.style.animationDelay = `${(idx * 0.05) % 0.8}s`;
      });
      
      // Start random walk letters
      const walkLetters = (iterations = 0) => {
        if (iterations > 20 || !channel.pending) return;
        
        // Spawn new walkers
        const numWalkers = Math.floor(Math.random() * 3) + 2;
        for (let i = 0; i < numWalkers; i++) {
          const letter = composeText[Math.floor(Math.random() * composeText.length)] || 'C';
          let currentIdx = Math.floor(Math.random() * 81);
          
          // Random walk algorithm
          const walk = (steps = 0) => {
            if (steps > 8 || !channel.pending) {
              gridCells[currentIdx]?.classList.remove('composing-active');
              gridCells[currentIdx]?.removeAttribute('data-compose-letter');
              return;
            }
            
            // Remove from old cell
            gridCells[currentIdx]?.classList.remove('composing-active');
            
            // Calculate next position (random walk on 9x9 grid)
            const x = currentIdx % 9;
            const y = Math.floor(currentIdx / 9);
            const moves = [];
            if (x > 0) moves.push(currentIdx - 1);     // left
            if (x < 8) moves.push(currentIdx + 1);     // right
            if (y > 0) moves.push(currentIdx - 9);     // up
            if (y < 8) moves.push(currentIdx + 9);     // down
            
            // Add diagonal moves (Monte Carlo style)
            if (x > 0 && y > 0) moves.push(currentIdx - 10); // up-left
            if (x < 8 && y > 0) moves.push(currentIdx - 8);  // up-right
            if (x > 0 && y < 8) moves.push(currentIdx + 8);  // down-left
            if (x < 8 && y < 8) moves.push(currentIdx + 10); // down-right
            
            // Pick random move and record entropy
            const moveIdx = Math.floor(Math.random() * moves.length);
            currentIdx = moves[moveIdx];
            entropy.push(moveIdx); // Dice roll data!
            
            // Add to new cell
            const cell = gridCells[currentIdx];
            if (cell) {
              cell.setAttribute('data-compose-letter', letter);
              cell.classList.add('composing-active');
            }
            
            // Continue walk
            setTimeout(() => walk(steps + 1), 150 + Math.random() * 100);
          };
          
          walk();
        }
        
        setTimeout(() => walkLetters(iterations + 1), 600);
      };
      
      walkLetters();
      
      // Store entropy for use as randomness source
      channel.entropy = entropy;
      await initSound();
      playComposingTick();
      const tickInterval = setInterval(() => playComposingTick(), 800);
      addMessageToChannel(channel, 'system', 'Composing scene…', { autoCollapse: true });
      try {
        const payload = {
          rules: createRuleContract(),
          currentState: channel.lastScene,
          scenario: scenarios[channel.scenario],
          message,
          history: channel.messages.slice(-6).map(m => ({ role: m.role, text: m.text }))
        };
        const scene = await callOpenAI('SceneAssembler', payload);
        channel.pendingTetrad = true;
        applyScene(channel, scene);
        const ringEntry = logRingEntry({
          type: 'scene',
          channelId: channel.id,
          channelName: channel.name,
          symbol: channel.name,
          headline: scene.sceneTitle || '',
          summary: scene.sceneSummary || ''
        });
        if (!channel.ringBinding) {
          channel.ringBinding = ringEntry.id;
        }
        const tetrad = await callOpenAI('TetradGenerator', {
          scenario: scenarios[channel.scenario],
          scene,
          history: channel.messages.slice(-2).map(m => ({ role: m.role, text: m.text })),
          perspective: channel.tetradPerspective || null
        });
        channel.tetrad = tetrad;
        renderTetradPanel(channel);
        persistState();
        playRevealChime();
        const lastMsg = channel.dom.messageList?.lastElementChild;
        if (lastMsg) lastMsg.classList.add('reveal');
      } catch (err) {
        console.error('Scene assembly error:', err);
        const errorDetail = err.stack || err.message || String(err);
        addMessageToChannel(channel, 'system', `Scene assembly failed:\n${errorDetail}`);
      } finally {
        clearInterval(tickInterval);
        channel.dom.column.classList.remove('composing');
        const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
        gridCells?.forEach(cell => {
          cell.classList.remove('loading');
          cell.classList.remove('composing-active');
          cell.removeAttribute('data-compose-letter');
        });
        channel.pending = false;
        channel.dom.sendBtn.disabled = false;
        channel.pendingTetrad = false;
        renderTetradPanel(channel);
      }
    }

    function createRuleContract() {
      return {
        blockTypes: blockPalette.map(p => p.type),
        gridSize: 9,
        maxPlacements: 18,
        schema: {
          sceneTitle: 'string',
          sceneSummary: 'string',
          entities: [{
            id: 'slug',
            type: 'blockType',
            name: 'string',
            location: 'slug|optional',
            relations: [{ type: 'string', target: 'slug' }]
          }],
          gridMapping: [{
            id: 'slug',
            type: 'blockType',
            label: 'string|optional',
            x: '0..8',
            y: '0..8'
          }],
          plot: {
            prior: { caution: '0..1', progress: '0..1' },
            posterior: { caution: '0..1', progress: '0..1' }
          },
          direction: 'up|down|left|right',
          tension: '0..1',
          scorecard: {
            progress: '0..1',
            caution: '0..1',
            movesRemaining: 'int',
            goalDistance: 'int'
          }
        }
      };
    }

    async function callOpenAI(kind, payload) {
      if (!appState.apiKey) {
        throw new Error('Missing API key. Click ◎ in corner menu to set your OpenAI API key.');
      }
      
      console.log('═══════════════════════════════════════');
      console.log('[API CALL] Type:', kind);
      console.log('[API CALL] API Key length:', appState.apiKey.length);
      console.log('[API CALL] Payload:', JSON.stringify(payload, null, 2));
      
      const prompts = {
        SceneAssembler: [
          {
            role: 'system',
            content: [
              'You are LEGOS-G (Liberation Engine Grid Ontology Synthesizer) - a HYPERCLAY world sculptor.',
              'Return valid JSON matching the schema provided.',
              'Place 8-14 elements on a 9x9 grid. Coordinates are 0-8.',
              'CRITICAL: BE TRANSFORMATIVE, NOT CONSERVATIVE.',
              '- REMOVE elements that are no longer relevant (2-4 removals per beat)',
              '- ADD new elements that emerge from the narrative (2-4 additions per beat)',
              '- Change entity states and conditions dramatically',
              '- Introduce new objects, environments, or complications',
              '- Remove obstacles once overcome, add new ones',
              '- The grid should feel ALIVE and REACTIVE, not static',
              'AVOID: Just shuffling existing elements around. That is boring.',
              'DO: Transform the scene. New entities appear, old ones vanish, the world reshapes itself.',
              'Position proximity = relationship strength. Distant = tension/separation.',
              'Use the full grid space. Create visual patterns that mirror story dynamics.',
              'Entity names should be full, memorable words (not truncated).',
              'Keep IDs consistent only for persistent elements. Generate new IDs for new elements.',
              'Update scorecard (progress 0-1, movesRemaining int, goalDistance int).'
            ].join(' ')
          },
          { role: 'user', content: JSON.stringify(payload) }
        ],
        TetradGenerator: [
          {
            role: 'system',
            content: payload.perspective
              ? `Generate TRANSFORMATIVE tetrad entries from ${payload.perspective}'s perspective. Each entry should CHANGE THE SCENE dramatically: add new elements, remove old ones, alter states. ENHANCE: what new elements/complications appear? REVERSE: what inverts or transforms? RETRIEVE: what returns or emerges? OBSOLESCE: what vanishes or fades? Be specific about entities/objects entering or leaving. Motivations: ${payload.perspective}'s desires/fears. Text <= 80 words, score 0-100. Return JSON.`
              : 'Generate TRANSFORMATIVE tetrad entries. Each must CHANGE THE SCENE: ENHANCE adds new elements/complications, REVERSE transforms existing ones, RETRIEVE brings back elements, OBSOLESCE removes elements. Be specific about what enters or exits the grid. Text <= 80 words, score 0-100. Return JSON.'
          },
          { role: 'user', content: JSON.stringify(payload) }
        ]
      };

      const requestBody = {
        model: 'gpt-4o-mini',
        temperature: kind === 'SceneAssembler' ? 0.7 : 0.8,
        messages: prompts[kind],
        max_tokens: kind === 'SceneAssembler' ? 2500 : 600,
        response_format: { type: 'json_object' }
      };
      
      console.log('[API CALL] Model:', requestBody.model);
      console.log('[API CALL] Temperature:', requestBody.temperature);
      console.log('[API CALL] Max Tokens:', requestBody.max_tokens);
      console.log('[API CALL] Messages:', prompts[kind].length, 'messages');
      prompts[kind].forEach((msg, idx) => {
        console.log(`  [${idx}] ${msg.role}:`, msg.content.substring(0, 100) + (msg.content.length > 100 ? '...' : ''));
      });
      
      let response;
      try {
        console.log('[API CALL] Sending request to OpenAI...');
        const startTime = Date.now();
        
        response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${appState.apiKey}`
          },
          body: JSON.stringify(requestBody)
        });
        
        const duration = Date.now() - startTime;
        console.log('[API RESPONSE] Status:', response.status, 'Duration:', duration + 'ms');
      } catch (fetchError) {
        console.error('[API ERROR] Fetch failed:', fetchError);
        console.error('[API ERROR] Error details:', {
          message: fetchError.message,
          name: fetchError.name,
          stack: fetchError.stack
        });
        throw new Error(`Network error: Cannot reach OpenAI API. Check your internet connection and API key. ${fetchError.message}`);
      }
      
      if (!response.ok) {
        const text = await response.text();
        console.error('[API] HTTP error:', response.status, text);
        if (response.status === 401) {
          throw new Error(`Invalid API key. Please check your OpenAI API key in corner menu (◎).`);
        } else if (response.status === 429) {
          throw new Error(`Rate limit exceeded. Please wait a moment and try again.`);
        }
        throw new Error(`HTTP ${response.status}: ${text}`);
      }
      const data = await response.json();
      console.log('[API RESPONSE] Usage:', data.usage);
      console.log('[API RESPONSE] Model:', data.model);
      console.log('[API RESPONSE] Finish reason:', data.choices?.[0]?.finish_reason);
      
      const raw = data.choices?.[0]?.message?.content;
      if (!raw) {
        console.error('[API ERROR] Empty response from API');
        throw new Error('Empty response from API.');
      }
      
      console.log('[API RESPONSE] Content length:', raw.length, 'characters');
      console.log('[API RESPONSE] Content preview:', raw.substring(0, 200) + (raw.length > 200 ? '...' : ''));
      
      try {
        const parsed = JSON.parse(raw);
        console.log('[API SUCCESS] Parsed JSON successfully');
        console.log('═══════════════════════════════════════\n');
        return parsed;
      } catch (parseErr) {
        console.error('[API ERROR] JSON parse error:', parseErr);
        console.error('[API ERROR] Raw response:', raw);
        
        // Try to repair truncated JSON by closing open structures
        console.log('[API REPAIR] Attempting to repair truncated JSON...');
        let repaired = raw.trim();
        
        // Count open braces/brackets
        const openBraces = (repaired.match(/\{/g) || []).length;
        const closeBraces = (repaired.match(/\}/g) || []).length;
        const openBrackets = (repaired.match(/\[/g) || []).length;
        const closeBrackets = (repaired.match(/\]/g) || []).length;
        
        // Remove incomplete string at end
        if (repaired.endsWith('"')) {
          repaired = repaired.slice(0, -1) + '" ';
        } else if (!repaired.endsWith('}') && !repaired.endsWith(']')) {
          // Find last complete property
          const lastComma = repaired.lastIndexOf(',');
          const lastBrace = repaired.lastIndexOf('}');
          const lastBracket = repaired.lastIndexOf(']');
          const cutPoint = Math.max(lastComma, lastBrace, lastBracket);
          if (cutPoint > 0) {
            repaired = repaired.substring(0, cutPoint + 1);
          }
        }
        
        // Close open arrays
        for (let i = 0; i < openBrackets - closeBrackets; i++) {
          repaired += ']';
        }
        
        // Close open objects
        for (let i = 0; i < openBraces - closeBraces; i++) {
          repaired += '}';
        }
        
        console.log('[API REPAIR] Repaired JSON:', repaired.substring(Math.max(0, repaired.length - 200)));
        
        try {
          const parsed = JSON.parse(repaired);
          console.log('[API SUCCESS] Repaired JSON parsed successfully!');
          console.log('═══════════════════════════════════════\n');
          return parsed;
        } catch (repairErr) {
          console.error('[API ERROR] Repair failed:', repairErr);
          throw new Error(`Invalid JSON from API (repair failed): ${parseErr.message}. Raw: ${raw.substring(0, 200)}`);
        }
      }
    }

    function showSceneLog(changes) {
      // Grid IS the terminal - log to console only
      console.log('[SCENE CHANGES]', changes.join(' | '));
    }
    
    function applyScene(channel, scene) {
      const oldScene = channel.lastScene;
      channel.lastScene = scene;
      channel.ledger.push(scene);
      
      // Track what changed
      const changes = [];
      const oldPositions = new Map();
      
      if (oldScene?.gridMapping) {
        oldScene.gridMapping.forEach(item => {
          oldPositions.set(item.id, {x: item.x, y: item.y, type: item.type});
        });
      }
      
      // Animate old cells with different effects based on what happens to them
      const oldCells = channel.dom.gridEl?.querySelectorAll('.grid-cell.occupied');
      oldCells?.forEach((cell, idx) => {
        const y = parseInt(cell.dataset.y);
        const x = parseInt(cell.dataset.x);
        const oldCell = channel.grid[y]?.[x];
        
        if (!oldCell) return;
        
        // Check if this element appears in new scene
        const newPlacement = (scene.gridMapping || []).find(p => p.id === oldCell.id);
        
        setTimeout(() => {
          if (!newPlacement) {
            // Element DISAPPEARS - dramatic fade with red tint
            cell.style.transition = 'opacity 0.5s, transform 0.5s, filter 0.5s, box-shadow 0.5s';
            cell.style.opacity = '0';
            cell.style.transform = 'scale(0) rotate(180deg)';
            cell.style.filter = 'blur(4px) hue-rotate(-30deg)';
            cell.style.boxShadow = '0 0 20px rgba(248, 113, 113, 0.8)';
            changes.push(`❌ ${oldCell.label || oldCell.type} disappeared`);
            
            // Show terminal-style status on cell
            const status = document.createElement('div');
            status.style.cssText = `
              position: absolute;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              font-size: 7px;
              font-family: 'Courier New', monospace;
              color: #f87171;
              letter-spacing: 0.1em;
              pointer-events: none;
              text-shadow: 0 0 8px #f87171;
            `;
            status.textContent = 'REMOVED';
            cell.style.position = 'relative';
            cell.appendChild(status);
            setTimeout(() => status.remove(), 1500);
          } else if (newPlacement.x !== x || newPlacement.y !== y) {
            // Element MOVES - slide out with blue tint
            const dx = (newPlacement.x - x) * 100;
            const dy = (newPlacement.y - y) * 100;
            cell.style.transition = 'transform 0.6s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s, box-shadow 0.3s';
            cell.style.transform = `translate(${dx}px, ${dy}px) scale(0.8)`;
            cell.style.opacity = '0.3';
            cell.style.boxShadow = '0 0 20px rgba(96, 165, 250, 0.6)';
            changes.push(`↔ ${oldCell.label || oldCell.type} moved (${x},${y})→(${newPlacement.x},${newPlacement.y})`);
          } else {
            // Element STAYS - gentle fade
            cell.style.transition = 'opacity 0.3s';
            cell.style.opacity = '0.5';
          }
        }, idx * 15);
      });
      
      // Display changes in terminal log overlay
      if (changes.length) {
        console.log('[SCENE UPDATE]', changes.join(' | '));
        showSceneLog(changes);
      }
      
      setTimeout(() => {
        channel.grid = createEmptyGrid();
        channel.cells = {};
        
        const placements = (scene.gridMapping || []).slice(0, 18);
        const newElements = [];
        
        placements.forEach(item => {
          if (item.x < 0 || item.x > 8 || item.y < 0 || item.y > 8) return;
          const entity = (scene.entities || []).find(e => e.id === item.id) || null;
          const label = sanitizeLabel(entity?.name || item.label || '');
          channel.grid[item.y][item.x] = {
            id: item.id,
            type: item.type,
            symbol: blockPalette.find(p => p.type === item.type)?.symbol || item.type[0],
            label,
            entity
          };
          logCellEvent(channel, item.x, item.y, `Agent placed ${item.type}${label ? `: ${label}` : ''}`);
          
          // Track new elements
          if (!oldPositions.has(item.id)) {
            newElements.push(`✨ ${label || item.type} appeared @ (${item.x},${item.y})`);
          }
        });
        
        // Show new elements in log
        if (newElements.length) {
          showSceneLog(newElements);
        }
        
        channel.observer = {
          plot: scene.plot || channel.observer.plot,
          direction: scene.direction || 'up',
          tension: scene.tension ?? channel.observer.tension,
          narrative: scene.sceneSummary || channel.observer.narrative
        };
        channel.scorecard = scene.scorecard || createDefaultScorecard();

        // Auto-name blank canvas channels based on scene
        if (channel.scenario === 'blank' && scene.sceneTitle) {
          const generatedName = sanitizeHandle(scene.sceneTitle, channel.symbolicId);
          if (generatedName && generatedName !== 'BLANK CANV') {
            channel.name = generatedName;
          }
        }
        
        addMessageToChannel(channel, 'assistant', `${scene.sceneTitle}\n${scene.sceneSummary}`);
        renderChannel(channel);
      }, 400); // Delay to show clearing animation

      // Trigger animations for placed elements
      setTimeout(() => {
        const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell.occupied');
        gridCells?.forEach((cell, idx) => {
          const y = parseInt(cell.dataset.y);
          const x = parseInt(cell.dataset.x);
          const cellData = channel.grid[y][x];
          if (!cellData) return;
          
          // Check if this is a NEW element (wasn't in old scene)
          const isNew = oldPositions.size > 0 && !oldPositions.has(cellData.id);
          const oldPos = oldPositions.get(cellData.id);
          const moved = oldPos && (oldPos.x !== x || oldPos.y !== y);
          
          setTimeout(() => {
            if (isNew) {
              // NEW element - dramatic entrance
              cell.style.animation = 'none';
              cell.style.transform = 'scale(0) rotate(-180deg)';
              cell.style.opacity = '0';
              
              // Show terminal status - color by element type
              const status = document.createElement('div');
              const typeColor = cellData.type === 'Entity' ? '#86efac' : 
                               cellData.type === 'Object' ? '#60a5fa' : 
                               cellData.type === 'Environment' ? '#c084fc' : '#fbbf24';
              status.style.cssText = `
                position: absolute;
                top: -8px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 6px;
                font-family: 'Courier New', monospace;
                color: ${typeColor};
                letter-spacing: 0.15em;
                pointer-events: none;
                white-space: nowrap;
                text-shadow: 0 0 8px ${typeColor};
                animation: sparkle 3s ease-in-out infinite;
              `;
              status.textContent = '✨ NEW';
              cell.style.position = 'relative';
              cell.appendChild(status);
              
              setTimeout(() => {
                cell.style.transition = 'all 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
                cell.style.transform = 'scale(1) rotate(0)';
                cell.style.opacity = '1';
                // Keep NEW label longer with sparkle
                setTimeout(() => status.remove(), 4000);
              }, 50);
            } else if (moved) {
              // MOVED element - pulse
              cell.style.animation = 'pulse 0.6s ease-in-out';
              
              // Show terminal status - color by element type
              const status = document.createElement('div');
              const typeColor = cellData.type === 'Entity' ? '#86efac' : 
                               cellData.type === 'Object' ? '#60a5fa' : 
                               cellData.type === 'Environment' ? '#c084fc' : '#fbbf24';
              status.style.cssText = `
                position: absolute;
                top: -8px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 6px;
                font-family: 'Courier New', monospace;
                color: ${typeColor};
                letter-spacing: 0.15em;
                pointer-events: none;
                white-space: nowrap;
                text-shadow: 0 0 8px ${typeColor};
              `;
              status.textContent = '↔ MOVED';
              cell.style.position = 'relative';
              cell.appendChild(status);
              setTimeout(() => status.remove(), 2000);
            }
            
            // Ripple effect
            cell.classList.add('resonance-field');
            setTimeout(() => cell.classList.remove('resonance-field'), 1200);
          }, idx * 150); // Slower stagger for smoother appearance
        });
      }, 450); // Longer delay to show transitions
    }

    // Dice roll using entropy from random walks
    function rollDice(channel, sides = 6, count = 1) {
      if (!channel.entropy || channel.entropy.length === 0) {
        // Fallback to Math.random if no entropy
        return Array.from({ length: count }, () => Math.floor(Math.random() * sides) + 1);
      }
      
      const rolls = [];
      for (let i = 0; i < count; i++) {
        // Consume entropy from the random walk
        const entropyIdx = channel.entropy.shift();
        if (entropyIdx === undefined) {
          // Entropy depleted, use standard random
          rolls.push(Math.floor(Math.random() * sides) + 1);
        } else {
          // Use entropy value, map to dice range
          const roll = (entropyIdx % sides) + 1;
          rolls.push(roll);
        }
      }
      
      // Log the roll for narrative purposes
      const rollText = rolls.length === 1 ? `Rolled ${rolls[0]}` : `Rolled ${rolls.join(', ')}`;
      console.log(`[DICE] ${rollText} using entropy (${channel.entropy.length} remaining)`);
      
      return rolls;
    }
    
    function logCellEvent(channel, x, y, text) {
      const key = `${x},${y}`;
      if (!channel.cells[key]) channel.cells[key] = [];
      channel.cells[key].push({ text, timestamp: new Date().toISOString() });
    }

    function gatherNearbyCells(channel, x, y, radius = 2.5) {
      const results = [];
      channel.grid.forEach((row, yy) => {
        row.forEach((cell, xx) => {
          if (!cell || (xx === x && yy === y)) return;
          const dx = xx - x;
          const dy = yy - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance <= radius) {
            results.push({ cell, x: xx, y: yy, distance });
          }
        });
      });
      return results.sort((a, b) => a.distance - b.distance);
    }

    function describeCellEnvironment(channel, x, y) {
      const cell = channel.grid[y]?.[x] || null;
      const neighbours = gatherNearbyCells(channel, x, y);
      const observer = channel.observer || {};
      const scorecard = channel.scorecard || {};
      const pieces = [];
      if (neighbours.length) {
        const sample = neighbours.slice(0, 3).map(item => {
          const label = item.cell.label || item.cell.type;
          return `${label} @ (${item.x},${item.y})`;
        }).join('; ');
        pieces.push(`Nearby signals: ${sample}.`);
      } else {
        pieces.push('Nearby signals: none detected within two cells.');
      }
      if (observer.tension != null) {
        pieces.push(`Scene tension ${Math.round((observer.tension || 0) * 100)}%.`);
      }
      if (observer.direction) {
        pieces.push(`Narrative drift ${observer.direction.toUpperCase()}.`);
      }
      if (scorecard.progress != null || scorecard.caution != null) {
        const progress = scorecard.progress != null ? (scorecard.progress * 100).toFixed(0) : '0';
        const caution = scorecard.caution != null ? (scorecard.caution * 100).toFixed(0) : '0';
        pieces.push(`Progress ${progress}%, caution ${caution}%.`);
      }
      if (!cell) {
        pieces.push('Cell is currently empty, awaiting placement.');
      }
      return pieces.join(' ');
    }

    function computeRelationshipScores(channel, x, y) {
      const source = channel.grid[y]?.[x];
      if (!source) return [];
      const relations = source.entity?.relations || [];
      const results = [];
      channel.grid.forEach((row, yy) => {
        row.forEach((cell, xx) => {
          if (!cell || (xx === x && yy === y)) return;
          const dx = xx - x;
          const dy = yy - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const proximity = 1 / (1 + distance);
          const typeBoost = cell.type === source.type ? 0.15 : 0;
          const relationBoost = relations.some(rel => rel.target === cell.id) ? 0.25 : 0;
          const score = Math.min(0.99, proximity + typeBoost + relationBoost);
          const label = sanitizeLabel(cell.label || `${cell.type} (${cell.symbol || '?'})`);
          results.push({
            label,
            type: cell.type,
            score,
            distance,
            relation: relationBoost > 0
          });
        });
      });
      return results.sort((a, b) => b.score - a.score).slice(0, 5);
    }

    function openCellOverlay(channel, x, y) {
      const cell = channel.grid[y][x];
      const logs = channel.cells[`${x},${y}`] || [];
      const content = document.getElementById('cellOverlayContent');
      content.innerHTML = '';
      const close = document.createElement('button');
      close.className = 'close-overlay';
      close.textContent = '×';
      close.addEventListener('click', () => document.getElementById('cellOverlay').classList.remove('active'));
      content.appendChild(close);

      const header = document.createElement('div');
      header.className = 'overlay-section';
      const label = document.createElement('div');
      label.className = 'overlay-label';
      label.textContent = `${channel.name} · CELL (${x}, ${y})`;
      const value = document.createElement('div');
      value.className = 'overlay-value';
      value.textContent = cell ? `${cell.type} · ${cell.label || '—'}` : 'Empty cell';
      header.appendChild(label);
      header.appendChild(value);
      content.appendChild(header);

      if (cell?.entity) {
        if (cell.entity.description) {
          const section = document.createElement('div');
          section.className = 'overlay-section';
          const l = document.createElement('div');
          l.className = 'overlay-label';
          l.textContent = 'Description';
          const v = document.createElement('div');
          v.className = 'overlay-value';
          v.textContent = cell.entity.description;
          section.appendChild(l);
          section.appendChild(v);
          content.appendChild(section);
        }
        if (cell.entity.relations?.length) {
          const section = document.createElement('div');
          section.className = 'overlay-section';
          const l = document.createElement('div');
          l.className = 'overlay-label';
          l.textContent = 'Relations';
          section.appendChild(l);
          cell.entity.relations.forEach(rel => {
            const v = document.createElement('div');
            v.className = 'overlay-value';
            v.textContent = `${rel.type}: ${rel.target}`;
            section.appendChild(v);
          });
          content.appendChild(section);
        }
      }

      if (logs.length) {
        const section = document.createElement('div');
        section.className = 'overlay-section';
        const l = document.createElement('div');
        l.className = 'overlay-label';
        l.textContent = 'Event History';
        section.appendChild(l);
        logs.slice().reverse().forEach(log => {
          const v = document.createElement('div');
          v.className = 'overlay-value';
          v.textContent = `${new Date(log.timestamp).toLocaleTimeString()} · ${log.text}`;
          section.appendChild(v);
        });
        content.appendChild(section);
      }

      if (channel.ledger.length) {
        const section = document.createElement('div');
        section.className = 'overlay-section';
        const label = document.createElement('div');
        label.className = 'overlay-label';
        label.textContent = 'Recent Scenes';
        section.appendChild(label);
        channel.ledger.slice(-3).reverse().forEach(scene => {
          const summary = (scene.sceneSummary || '').trim();
          const compact = summary.length > 160 ? `${summary.slice(0, 160)}…` : summary;
          const value = document.createElement('div');
          value.className = 'overlay-value';
          value.textContent = `${scene.sceneTitle || 'Scene'} — ${compact}`;
          section.appendChild(value);
        });
        content.appendChild(section);
      }

      const awareness = describeCellEnvironment(channel, x, y);
      if (awareness) {
        const section = document.createElement('div');
        section.className = 'overlay-section';
        const label = document.createElement('div');
        label.className = 'overlay-label';
        label.textContent = 'Local Awareness';
        const value = document.createElement('div');
        value.className = 'overlay-value';
        value.textContent = awareness;
        section.appendChild(label);
        section.appendChild(value);
        content.appendChild(section);
      }

      const relationshipScores = computeRelationshipScores(channel, x, y);
      if (relationshipScores.length) {
        const section = document.createElement('div');
        section.className = 'overlay-section';
        const label = document.createElement('div');
        label.className = 'overlay-label';
        label.textContent = 'Relational Probabilities';
        section.appendChild(label);
        relationshipScores.forEach(item => {
          const value = document.createElement('div');
          value.className = 'overlay-value';
          const percent = Math.round(item.score * 100);
          value.textContent = `${item.label} — ${percent}% resonance` + (item.relation ? ' (linked)' : '');
          section.appendChild(value);
        });
        content.appendChild(section);
      }

      const actionRow = [];
      
      // Send to Chat button
      if (cell) {
        const sendToChatBtn = document.createElement('button');
        sendToChatBtn.className = 'primary-btn';
        sendToChatBtn.textContent = 'SEND TO CHAT';
        sendToChatBtn.addEventListener('click', () => {
          const cellContext = `Regarding ${cell.label || cell.type} at (${x},${y}): `;
          if (channel.dom?.input) {
            channel.dom.input.value = cellContext;
            channel.dom.input.focus();
          }
          document.getElementById('cellOverlay').classList.remove('active');
        });
        actionRow.push(sendToChatBtn);
      }
      
      const spawnBtn = document.createElement('button');
      spawnBtn.className = 'primary-btn';
      spawnBtn.textContent = 'SPAWN POV CHANNEL';
      spawnBtn.addEventListener('click', () => {
        document.getElementById('cellOverlay').classList.remove('active');
        spawnCellPerspectiveChannel(channel, x, y, cell);
      });
      actionRow.push(spawnBtn);

      if (cell) {
        const canRunPerspective = Boolean(appState.apiKey);
        const perspectiveBtn = document.createElement('button');
        perspectiveBtn.className = 'primary-btn';
        perspectiveBtn.textContent = 'RUN ELEMENT PERSPECTIVE';
        perspectiveBtn.disabled = !canRunPerspective;
        if (canRunPerspective) {
          perspectiveBtn.addEventListener('click', () => {
            document.getElementById('cellOverlay').classList.remove('active');
            showEntityPerspective(channel, x, y, cell);
          });
        } else {
          perspectiveBtn.title = 'Store an API key to analyze this element POV.';
        }
        actionRow.push(perspectiveBtn);
        
        // Add Tetrad Intervention button
        const tetradBtn = document.createElement('button');
        tetradBtn.className = 'primary-btn tetrad-intervention-btn';
        tetradBtn.innerHTML = '⋔ TETRAD INTERVENTION';
        tetradBtn.disabled = !canRunPerspective;
        
        // Glowing effect when API ready
        if (canRunPerspective) {
          tetradBtn.classList.add('glow-active');
          tetradBtn.addEventListener('click', async () => {
            tetradBtn.disabled = true;
            tetradBtn.textContent = '⋔ GENERATING...';
            tetradBtn.classList.add('glow-processing');
            
            try {
              const tetrad = await callOpenAI('TetradGenerator', {
                scenario: scenarios[channel.scenario],
                scene: channel.lastScene,
                history: channel.messages.slice(-2).map(m => ({ role: m.role, text: m.text })),
                perspective: cell.label,
                elementContext: {
                  type: cell.type,
                  position: {x, y},
                  environment: describeCellEnvironment(channel, x, y)
                }
              });
              
              channel.tetrad = tetrad;
              channel.tetradPerspective = cell.label;
              persistState();
              renderChannelMessages(channel);
              
              tetradBtn.textContent = '✓ TETRAD GENERATED';
              tetradBtn.classList.remove('glow-processing');
              tetradBtn.classList.add('glow-success');
              
              setTimeout(() => {
                document.getElementById('cellOverlay').classList.remove('active');
              }, 1000);
            } catch (err) {
              tetradBtn.textContent = '✗ GENERATION FAILED';
              tetradBtn.classList.remove('glow-processing');
              tetradBtn.disabled = false;
            }
          });
        } else {
          tetradBtn.title = 'Store an API key to generate tetrad for this element.';
        }
        
        actionRow.push(tetradBtn);
      }

      if (actionRow.length) {
        const actions = document.createElement('div');
        actions.className = 'overlay-action-row';
        actionRow.forEach(btn => actions.appendChild(btn));
        content.appendChild(actions);
      }

      document.getElementById('cellOverlay').classList.add('active');
    }

    async function showEntityPerspective(channel, x, y, cell) {
      const panel = document.getElementById('perspectiveOverlayContent');
      panel.innerHTML = '';
      const close = document.createElement('button');
      close.className = 'close-overlay';
      close.textContent = '×';
      close.addEventListener('click', () => document.getElementById('perspectiveOverlay').classList.remove('active'));
      panel.appendChild(close);

      // Show loading screen
      const loadingScreen = document.createElement('div');
      loadingScreen.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 40px 20px;
        gap: 16px;
      `;
      
      const loadingText = document.createElement('div');
      loadingText.style.cssText = `
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.15em;
        color: var(--accent);
        text-transform: uppercase;
        text-align: center;
      `;
      loadingText.textContent = `Analyzing ${cell.label || cell.type}'s Perspective...`;
      
      const loadingSubtext = document.createElement('div');
      loadingSubtext.style.cssText = `
        font-size: 9px;
        color: var(--text-muted);
        text-align: center;
        max-width: 300px;
      `;
      loadingSubtext.textContent = 'Consulting current scene and relationships...';
      
      loadingScreen.appendChild(loadingText);
      loadingScreen.appendChild(loadingSubtext);
      panel.appendChild(loadingScreen);
      
      // Show message history dots for this cell
      const cellLogs = channel.cells[`${x},${y}`] || [];
      if (cellLogs.length) {
        const historySection = document.createElement('div');
        historySection.className = 'overlay-section';
        historySection.style.cssText = 'display: flex; gap: 6px; align-items: center; padding: 8px 0;';
        
        const historyLabel = document.createElement('div');
        historyLabel.className = 'overlay-label';
        historyLabel.textContent = 'Modified by:';
        historyLabel.style.marginBottom = '0';
        historySection.appendChild(historyLabel);
        
        const dotRow = document.createElement('div');
        dotRow.style.cssText = 'display: flex; gap: 4px; flex-wrap: wrap;';
        
        cellLogs.slice(-5).forEach((log, idx) => {
          const dot = document.createElement('span');
          dot.style.cssText = `
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: ${channel.channelColor};
            border: 2px solid ${idx === cellLogs.length - 1 ? 'var(--accent)' : 'var(--border)'};
            display: inline-block;
            flex-shrink: 0;
            box-shadow: 0 0 8px ${channel.channelColor};
          `;
          dot.title = `${new Date(log.timestamp).toLocaleTimeString()}: ${log.text}`;
          dotRow.appendChild(dot);
        });
        
        historySection.appendChild(dotRow);
        panel.appendChild(historySection);
      }
      
      document.getElementById('perspectiveOverlay').classList.add('active');

      const entityPayload = cell?.entity ? { ...cell.entity } : {
        name: cell?.label || `${cell?.type || 'Cell'} (${x},${y})`,
        type: cell?.type || 'Unknown',
        relations: []
      };
      if (!entityPayload.relations) {
        entityPayload.relations = [];
      }
      const environmentSummary = describeCellEnvironment(channel, x, y);
      const relationshipScores = computeRelationshipScores(channel, x, y);

      try {
        console.log('[PERSPECTIVE API] Starting perspective analysis for:', cell.label || cell.type);
        console.log('[PERSPECTIVE API] Scene context:', channel.lastScene?.sceneTitle);
        
        // Always generate single standard perspective
        // Tetrad mode handled separately through tetrad chips
        let analyses = [];
        let analysis = null; // Define at function scope
        
        if (false) { // Disabled tetrad mode in perspective
          // Generate 4 defractive perspectives through tetrad lenses
          const tetradLenses = [
            {key: 'enhance', label: 'ENHANCE', prompt: 'amplifying and intensifying their current situation', icon: '▲'},
            {key: 'reverse', label: 'REVERSE', prompt: 'reversing or inverting their current trajectory', icon: '⇄'},
            {key: 'retrieve', label: 'RETRIEVE', prompt: 'retrieving past elements and memories', icon: '↺'},
            {key: 'obsolesce', label: 'OBSOLESCE', prompt: 'elements becoming obsolete or fading away', icon: '▼'}
          ];
          
          // Generate all 4 perspectives in parallel
          const promises = tetradLenses.map(lens => 
            fetch('https://api.openai.com/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${appState.apiKey}`
              },
              body: JSON.stringify({
                model: 'gpt-4o-mini',
                temperature: 0.7,
                messages: [
                  {
                    role: 'system',
                    content: `You analyze an entity's perspective through the tetrad lens of "${lens.label}" (${lens.prompt}). Return JSON with perspective, emotionalState, plotImpact, nextMove, all filtered through this ${lens.label} lens. Keep each field under 60 words.`
                  },
                  {
                    role: 'user',
                    content: JSON.stringify({
                      scenario: scenarios[channel.scenario],
                      currentScene: channel.lastScene,
                      entity: entityPayload,
                      cellType: cell?.type || 'Unknown',
                      cellPosition: { x, y },
                      plot: channel.observer.plot,
                      environment: environmentSummary,
                      tetradLens: lens.label
                    })
                  }
                ],
                max_tokens: 400,
                response_format: { type: 'json_object' }
              })
            }).then(r => r.ok ? r.json() : Promise.reject(`HTTP ${r.status}`))
              .then(data => ({
                ...JSON.parse(data.choices?.[0]?.message?.content || '{}'),
                lens: lens
              }))
          );
          
          analyses = await Promise.all(promises);
        } else {
          // Standard single perspective
          console.log('[PERSPECTIVE API] Generating standard perspective');
          console.log('[PERSPECTIVE API] Entity:', entityPayload.name);
          console.log('[PERSPECTIVE API] Environment:', environmentSummary);
          
          const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${appState.apiKey}`
            },
            body: JSON.stringify({
              model: 'gpt-4o-mini',
              temperature: 0.7,
              messages: [
                {
                  role: 'system',
                  content: 'You analyze an entity perspective in a LEGOS grid. Return JSON with perspective, emotionalState, plotImpact, nextMove.'
                },
                {
                  role: 'user',
                  content: JSON.stringify({
                    scenario: scenarios[channel.scenario],
                    currentScene: channel.lastScene,
                    entity: entityPayload,
                    cellType: cell?.type || 'Unknown',
                    cellPosition: { x, y },
                    plot: channel.observer.plot,
                    environment: environmentSummary
                  })
                }
              ],
              max_tokens: 500,
              response_format: { type: 'json_object' }
            })
          });
          if (!response.ok) {
            console.error('[PERSPECTIVE API] HTTP error:', response.status);
            throw new Error(`HTTP ${response.status}`);
          }
          const data = await response.json();
          console.log('[PERSPECTIVE API] Response received');
          console.log('[PERSPECTIVE API] Usage:', data.usage);
          
          const rawContent = data.choices?.[0]?.message?.content || '{}';
          console.log('[PERSPECTIVE API] Raw content:', rawContent.substring(0, 200));
          
          analysis = JSON.parse(rawContent);
          console.log('[PERSPECTIVE API] Parsed analysis:', analysis);
          analyses = [analysis];
        }

        console.log('[PERSPECTIVE] Total analyses:', analyses.length);
        console.log('[PERSPECTIVE] First analysis:', analyses[0]);

        panel.innerHTML = '';
        const closeBtn = document.createElement('button');
        closeBtn.className = 'close-overlay';
        closeBtn.textContent = '×';
        closeBtn.addEventListener('click', () => document.getElementById('perspectiveOverlay').classList.remove('active'));
        panel.appendChild(closeBtn);

        // Always use standard mode display (never tetrad cards)
        if (false && analyses.length > 1) {
          // Tetrad mode: Show 4 defractive perspectives as cards
          const header = document.createElement('div');
          header.style.cssText = 'font-size: 12px; font-weight: 700; letter-spacing: 0.15em; color: var(--accent); margin-bottom: 16px; text-transform: uppercase; text-align: center;';
          header.textContent = `${cell.label || cell.type} · DEFRACTIVE PERSPECTIVES`;
          panel.appendChild(header);
          
          const subheader = document.createElement('div');
          subheader.style.cssText = 'font-size: 9px; color: var(--text-muted); margin-bottom: 16px; text-align: center;';
          subheader.textContent = 'Four perspectives through tetrad lenses — Click any to add to chat';
          panel.appendChild(subheader);
          
          const cardsContainer = document.createElement('div');
          cardsContainer.style.cssText = 'display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;';
          
          analyses.forEach(analysis => {
            const card = document.createElement('div');
            card.style.cssText = `
              background: var(--panel-dark);
              border: 2px solid var(--border);
              border-radius: 8px;
              padding: 12px;
              cursor: pointer;
              transition: all 0.2s;
            `;
            
            const cardHeader = document.createElement('div');
            cardHeader.style.cssText = 'display: flex; align-items: center; gap: 6px; margin-bottom: 8px;';
            cardHeader.innerHTML = `
              <span style="font-size: 18px;">${analysis.lens.icon}</span>
              <span style="font-size: 9px; font-weight: 700; letter-spacing: 0.1em; color: var(--accent);">${analysis.lens.label}</span>
            `;
            card.appendChild(cardHeader);
            
            ['perspective', 'emotionalState', 'nextMove'].forEach(key => {
              if (!analysis[key]) return;
              const field = document.createElement('div');
              field.style.cssText = 'margin-bottom: 8px;';
              field.title = analysis[key]; // Hover tooltip
              const label = key === 'nextMove' ? 'NEXT ACTION' : key.replace(/([A-Z])/g, ' $1').trim();
              field.innerHTML = `
                <div style="font-size: 7px; text-transform: uppercase; color: var(--text-muted); margin-bottom: 2px; letter-spacing: 0.1em;">${label}</div>
                <div style="font-size: 9px; line-height: 1.4; color: var(--text);">${analysis[key]}</div>
              `;
              card.appendChild(field);
            });
            
            // Add copy button to card
            const copyBtn = document.createElement('button');
            copyBtn.style.cssText = `
              margin-top: 8px;
              padding: 4px 8px;
              background: var(--accent);
              color: var(--bg);
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 8px;
              font-weight: 700;
              text-transform: uppercase;
              width: 100%;
            `;
            copyBtn.textContent = '📋 COPY TO CHAT';
            copyBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const textarea = channel.dom?.input;
              if (textarea) {
                const text = `${analysis.lens.icon} ${analysis.lens.label}:\n${analysis.perspective}\n\nNext Move: ${analysis.nextMove}`;
                textarea.value = text;
                textarea.focus();
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
                copyBtn.textContent = '✓ COPIED';
                setTimeout(() => copyBtn.textContent = '📋 COPY TO CHAT', 1500);
              }
            });
            card.appendChild(copyBtn);
            
            card.addEventListener('mouseenter', () => {
              card.style.borderColor = 'var(--accent)';
              card.style.transform = 'scale(1.02)';
            });
            
            card.addEventListener('mouseleave', () => {
              card.style.borderColor = 'var(--border)';
              card.style.transform = '';
            });
            
            cardsContainer.appendChild(card);
          });
          
          panel.appendChild(cardsContainer);
        } else {
          // Standard mode: Show single perspective
          const analysis = analyses[0];
          const heading = document.createElement('div');
          heading.className = 'overlay-section clickable';
          heading.title = 'Click to send to chat';
          const heLabel = document.createElement('div');
          heLabel.className = 'overlay-label';
          heLabel.textContent = `${cell.label || cell.type} · Perspective`;
          const heVal = document.createElement('div');
          heVal.className = 'overlay-value';
          heVal.textContent = analysis.perspective || '—';
          heading.appendChild(heLabel);
          heading.appendChild(heVal);
          
          // Make section selectable - button appears on selection
          heading.style.position = 'relative';
          heading.style.cursor = 'pointer';
          heading.style.transition = 'all 0.2s';
          
          // Add red ball send button (hidden by default)
          const sendBtn = document.createElement('button');
          sendBtn.style.cssText = `
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%) scale(0);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(135deg, #f87171, #dc2626);
            border: 2px solid #991b1b;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: 0 4px 12px rgba(248, 113, 113, 0.6);
            z-index: 10;
            opacity: 0;
          `;
          sendBtn.textContent = '→';
          sendBtn.title = 'Send to input';
          
          // Click section to select and show button
          heading.addEventListener('click', (e) => {
            if (e.target === sendBtn) return; // Don't trigger if clicking button
            
            // Deselect all other sections
            panel.querySelectorAll('.overlay-section').forEach(s => {
              s.style.background = '';
              const btn = s.querySelector('button');
              if (btn) {
                btn.style.transform = 'translateY(-50%) scale(0)';
                btn.style.opacity = '0';
              }
            });
            
            // Select this section
            heading.style.background = 'var(--accent-soft)';
            sendBtn.style.transform = 'translateY(-50%) scale(1)';
            sendBtn.style.opacity = '1';
          });
          
          sendBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const textarea = channel.dom?.input;
            if (textarea) {
              textarea.value = heVal.textContent;
              textarea.focus();
              textarea.style.height = 'auto';
              textarea.style.height = textarea.scrollHeight + 'px';
              
              // Flash and close
              heading.style.background = 'var(--accent)';
              sendBtn.style.transform = 'translateY(-50%) scale(1.2)';
              
              setTimeout(() => {
                // Close the modal
                document.getElementById('perspectiveOverlay').classList.remove('active');
              }, 300);
            }
          });
          heading.appendChild(sendBtn);
          panel.appendChild(heading);

          ['emotionalState', 'plotImpact', 'nextMove'].forEach(key => {
            if (!analysis[key]) return;
            const section = document.createElement('div');
            section.className = 'overlay-section';
            section.style.position = 'relative';
            section.style.cursor = 'pointer';
            section.style.transition = 'all 0.2s';
            
            const l2 = document.createElement('div');
            l2.className = 'overlay-label';
            const labelText = key === 'nextMove' ? 'NEXT ACTION' : key.replace(/([A-Z])/g, ' $1').toUpperCase();
            l2.textContent = labelText;
            const v2 = document.createElement('div');
            v2.className = 'overlay-value';
            v2.textContent = analysis[key];
            section.appendChild(l2);
            section.appendChild(v2);
            
            // Add red ball send button (hidden by default)
            const fieldSendBtn = document.createElement('button');
            fieldSendBtn.style.cssText = `
              position: absolute;
              top: 50%;
              right: 12px;
              transform: translateY(-50%) scale(0);
              width: 40px;
              height: 40px;
              border-radius: 50%;
              background: linear-gradient(135deg, #f87171, #dc2626);
              border: 2px solid #991b1b;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 18px;
              transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
              box-shadow: 0 4px 12px rgba(248, 113, 113, 0.6);
              z-index: 10;
              opacity: 0;
            `;
            fieldSendBtn.textContent = '→';
            fieldSendBtn.title = 'Send to input';
            
            // Click section to select and show button
            section.addEventListener('click', (e) => {
              if (e.target === fieldSendBtn) return;
              
              // Deselect all other sections
              panel.querySelectorAll('.overlay-section').forEach(s => {
                s.style.background = '';
                const btn = s.querySelector('button');
                if (btn) {
                  btn.style.transform = 'translateY(-50%) scale(0)';
                  btn.style.opacity = '0';
                }
              });
              
              // Select this section
              section.style.background = 'var(--accent-soft)';
              fieldSendBtn.style.transform = 'translateY(-50%) scale(1)';
              fieldSendBtn.style.opacity = '1';
            });
            
            fieldSendBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const textarea = channel.dom?.input;
              if (textarea) {
                textarea.value = v2.textContent;
                textarea.focus();
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
                
                // Flash and close
                section.style.background = 'var(--accent)';
                fieldSendBtn.style.transform = 'translateY(-50%) scale(1.2)';
                
                setTimeout(() => {
                  // Close the modal
                  document.getElementById('perspectiveOverlay').classList.remove('active');
                }, 300);
              }
            });
            
            section.appendChild(fieldSendBtn);
            panel.appendChild(section);
          });
        }
        
        // Log perspective to ring memory for narrative depth
        const firstAnalysis = analyses[0];
        const perspectiveSummary = `${cell.label || cell.type}: ${firstAnalysis.perspective ? firstAnalysis.perspective.substring(0, 100) : 'analyzed'}`;
        logRingEntry({
          type: 'perspective',
          channelId: channel.id,
          channelName: channel.name,
          symbol: `${cell.symbol || cell.type[0]}@(${x},${y})`,
          headline: `Perspective: ${cell.label || cell.type}`,
          summary: perspectiveSummary,
          metadata: {
            cellPosition: { x, y },
            cellType: cell.type,
            analysis: analysis
          }
        });

        if (environmentSummary) {
          const section = document.createElement('div');
          section.className = 'overlay-section clickable';
          section.title = 'Click to send to chat';
          const lEnv = document.createElement('div');
          lEnv.className = 'overlay-label';
          lEnv.textContent = 'Local Awareness';
          const vEnv = document.createElement('div');
          vEnv.className = 'overlay-value';
          vEnv.textContent = environmentSummary;
          section.appendChild(lEnv);
          section.appendChild(vEnv);
          section.addEventListener('click', () => {
            const text = `${lEnv.textContent}: ${vEnv.textContent}`;
            sendPerspectiveToChat(channel, text);
          });
          panel.appendChild(section);
        }

        if (relationshipScores.length) {
          const section = document.createElement('div');
          section.className = 'overlay-section clickable';
          section.title = 'Click to send to chat';
          const lRel = document.createElement('div');
          lRel.className = 'overlay-label';
          lRel.textContent = 'Relational Probabilities';
          section.appendChild(lRel);
          const relationsText = relationshipScores.map(item => {
            const percent = Math.round(item.score * 100);
            return `${item.label} — ${percent}% resonance` + (item.relation ? ' (linked)' : '');
          }).join('; ');
          relationshipScores.forEach(item => {
            const value = document.createElement('div');
            value.className = 'overlay-value';
            const percent = Math.round(item.score * 100);
            value.textContent = `${item.label} — ${percent}% resonance` + (item.relation ? ' (linked)' : '');
            section.appendChild(value);
          });
          section.addEventListener('click', () => {
            const text = `${lRel.textContent}: ${relationsText}`;
            sendPerspectiveToChat(channel, text);

          });
          panel.appendChild(section);
        }

        const sendToChatBtn = document.createElement('button');
        sendToChatBtn.className = 'primary-btn';
        sendToChatBtn.textContent = 'SEND TO CHAT';
        sendToChatBtn.addEventListener('click', () => {
          const summary = `${cell.label || cell.type} perspective: ${analysis.perspective || ''}`;
          if (channel.dom?.input) {
            channel.dom.input.value = summary;
            channel.dom.input.focus();
          }
          document.getElementById('perspectiveOverlay').classList.remove('active');
        });
        
        const forkBtn = document.createElement('button');
        forkBtn.className = 'secondary-btn';
        forkBtn.textContent = 'FORK POV CHANNEL';
        forkBtn.addEventListener('click', () => {
          document.getElementById('perspectiveOverlay').classList.remove('active');
          spawnCellPerspectiveChannel(channel, x, y, cell);
        });
        
        const controlRow = document.createElement('div');
        controlRow.className = 'overlay-action-row';
        controlRow.appendChild(sendToChatBtn);
        controlRow.appendChild(forkBtn);
        panel.appendChild(controlRow);
      } catch (err) {
        panel.innerHTML = '';
        const closeBtn = document.createElement('button');
        closeBtn.className = 'close-overlay';
        closeBtn.textContent = '×';
        closeBtn.addEventListener('click', () => document.getElementById('perspectiveOverlay').classList.remove('active'));
        panel.appendChild(closeBtn);

        const fail = document.createElement('div');
        fail.className = 'overlay-section';
        const l = document.createElement('div');
        l.className = 'overlay-label';
        l.textContent = 'Perspective Failed';
        const v = document.createElement('div');
        v.className = 'overlay-value';
        v.textContent = err.message;
        fail.appendChild(l);
        fail.appendChild(v);
        panel.appendChild(fail);
      }
    }

    function spawnCellPerspectiveChannel(sourceChannel, x, y, cell) {
      const labelRoot = cell?.label || cell?.type || `Cell (${x},${y})`;
      const safeLabel = labelRoot.replace(/\s+/g, ' ').trim() || `Cell (${x},${y})`;
      const shortLabel = `${safeLabel}`.toUpperCase().slice(0, 16);
      const systemInstruction = [
        sourceChannel.systemInstruction,
        `Stay in viewpoint as ${safeLabel}. Anchor narrative to grid cell (${x},${y}) and reference its event history when relevant.`
      ].join('\n');

      const newChannel = createChannel({
        name: `${sourceChannel.name} • ${shortLabel} POV`,
        scenario: sourceChannel.scenario,
        systemInstruction,
        parentChannelId: sourceChannel.id,
        forkPoint: {
          mode: 'cell-perspective',
          coordinates: { x, y },
          cellId: cell?.id || null
        },
        grid: deepClone(sourceChannel.grid),
        cells: deepClone(sourceChannel.cells),
        observer: deepClone(sourceChannel.observer),
        scorecard: deepClone(sourceChannel.scorecard),
        tetrad: {},
        lastScene: deepClone(sourceChannel.lastScene),
        messages: []
      });

      addMessageToChannel(newChannel, 'system', `POV channel launched for ${safeLabel} at (${x},${y}).`);
      if (sourceChannel.lastScene?.sceneSummary) {
        const title = sourceChannel.lastScene.sceneTitle || 'Latest Scene';
        addMessageToChannel(
          newChannel,
          'system',
          `${title} — ${sourceChannel.lastScene.sceneSummary}`,
          { autoCollapse: true }
        );
      }
      if (newChannel.dom?.input) {
        newChannel.dom.input.value = `From ${safeLabel}'s perspective, ...`;
        newChannel.dom.input.focus();
      }
      showHelpBanner(`POV channel launched for ${safeLabel}.`);
      focusChannel(newChannel.id);
    }

    function routeMessage(sourceChannel, targetChannel, message) {
      addMessageToChannel(targetChannel, 'user', message.text, { fromChannel: sourceChannel.name });
      focusChannel(targetChannel.id);
      showHelpBanner(`Routed message to ${targetChannel.name}`);
    }

    function forkChannel(channel, message, mode, options = {}) {
      const messageId = message?.id ?? null;
      const idx = channel.messages.findIndex(m => m.id === messageId);
      const history = idx >= 0 ? channel.messages.slice(0, idx + 1) : channel.messages.slice();
      const label = forkLabels[mode] || 'Fork';
      const baseName = sanitizeHandle(`${channel.name}-${label}`, label);
      let newChannelConfig;

      if (mode === 'blank') {
        newChannelConfig = {
          name: baseName,
          scenario: channel.scenario,
          parentChannelId: channel.id,
          forkPoint: { messageId, mode },
          ringBinding: channel.ringBinding || null
        };
      } else if (mode === 'snapshot') {
        const snapshotId = options.snapshotId || window.prompt('Snapshot ID or name?');
        const snapshot = channel.snapshots.find(s => s.id === snapshotId || s.name === snapshotId);
        if (!snapshot) {
          showHelpBanner('Snapshot not found.');
          return;
        }
        newChannelConfig = {
          name: baseName,
          scenario: channel.scenario,
          parentChannelId: channel.id,
          forkPoint: { messageId, mode, snapshotId: snapshot.id },
          grid: deepClone(snapshot.grid),
          cells: deepClone(snapshot.cells),
          observer: deepClone(snapshot.observer),
          scorecard: deepClone(snapshot.scorecard),
          tetrad: deepClone(snapshot.tetrad),
          lastScene: deepClone(snapshot.lastScene),
          messages: deepClone(history),
          ringBinding: channel.ringBinding || null
        };
      } else if (mode === 'perspective') {
        const entityName = window.prompt('Which entity perspective?');
        const systemInstruction = `${channel.systemInstruction}
Focus entirely on the perspective of ${entityName || 'the selected entity'}. Provide POV insights per turn.`;
        newChannelConfig = {
          name: sanitizeHandle(`${channel.name}-POV`, baseName),
          scenario: channel.scenario,
          parentChannelId: channel.id,
          systemInstruction,
          forkPoint: { messageId, mode, entity: entityName },
          grid: deepClone(channel.grid),
          cells: deepClone(channel.cells),
          observer: deepClone(channel.observer),
          scorecard: deepClone(channel.scorecard),
          tetrad: {},
          lastScene: deepClone(channel.lastScene),
          messages: deepClone(history),
          ringBinding: channel.ringBinding || null
        };
      } else if (['continue', 'enhance', 'reverse', 'retrieve', 'obsolesce'].includes(mode)) {
        newChannelConfig = {
          name: baseName,
          scenario: channel.scenario,
          systemInstruction: channel.systemInstruction,
          parentChannelId: channel.id,
          forkPoint: { messageId, mode },
          grid: deepClone(channel.grid),
          cells: deepClone(channel.cells),
          observer: deepClone(channel.observer),
          scorecard: deepClone(channel.scorecard),
          tetrad: {},
          lastScene: deepClone(channel.lastScene),
          messages: deepClone(history),
          ringBinding: channel.ringBinding || null
        };
      } else {
        newChannelConfig = {
          name: baseName,
          scenario: channel.scenario,
          parentChannelId: channel.id,
          forkPoint: { messageId, mode },
          ringBinding: channel.ringBinding || null
        };
      }

      if (options.ringEntryId) {
        newChannelConfig.ringBinding = options.ringEntryId;
      }

      const forked = createChannel(newChannelConfig);
      if (mode !== 'blank') {
        if (['enhance', 'reverse', 'retrieve', 'obsolesce'].includes(mode) && channel.tetrad?.[mode]?.text) {
          addMessageToChannel(forked, 'system', `Forked via ${mode.toUpperCase()} tetrad option.`);
          addMessageToChannel(forked, 'user', channel.tetrad[mode].text, { forkLabel: mode.toUpperCase() });
        } else {
          addMessageToChannel(forked, 'system', `Forked from ${channel.name} @ message ${messageId ?? '—'} (${label}).`);
        }
      } else {
        addMessageToChannel(forked, 'system', 'Blank fork created. Describe a new trajectory.');
      }
      const forkEntry = logRingEntry({
        type: 'fork',
        channelId: forked.id,
        channelName: forked.name,
        symbol: forked.name,
        headline: `Forked via ${label}`,
        summary: message?.text || ''
      });
      forked.ringBinding = forkEntry.id;
      renderChannel(forked);
      
      // Animate colored ball moving to new forked channel
      setTimeout(() => animateChannelTransition(channel, forked), 100);
      
      renderTimeline();
      focusChannel(forked.id);
      persistState();
    }

    function setChannelScenario(channel, scenarioId) {
      if (!scenarios[scenarioId]) return;
      const previousDefault = resolveChannelName('', channel.scenario, channel.symbolicId);
      channel.scenario = scenarioId;
      if (channel.name === previousDefault) {
        channel.name = resolveChannelName('', scenarioId, channel.symbolicId);
      }
      channel.systemInstruction = scenarios[scenarioId].systemInstruction;
      channel.resetState();
      if (snapshotOverlayChannel === channel) {
        snapshotOverlayChannel = null;
        const overlay = document.getElementById('snapshotOverlay');
        if (overlay) overlay.classList.remove('active');
      }
      addMessageToChannel(channel, 'system', `${scenarios[scenarioId].name} scenario primed. ${scenarios[scenarioId].intro}`);
      if (scenarios[scenarioId].initialPrompt) {
        channel.dom.input.value = scenarios[scenarioId].initialPrompt;
      }
      renderChannel(channel);
      persistState();
    }

    function exportState() {
      const overlay = document.getElementById('exportOverlay');
      overlay.classList.remove('active');
      const payload = {
        exportedAt: new Date().toISOString(),
        theme: appState.theme,
        channels: appState.channels.map(ch => ch.serialize()),
        ring: {
          entries: ringMemory.entries,
          mainline: ringMemory.mainline,
          contextMode: ringMemory.contextMode,
          contextAnchor: ringMemory.contextAnchor,
          counter: ringEntryCounter
        }
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `legos-multi-channel-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      showHelpBanner('Exported multi-channel state.');
    }

    function handleImportFile(event) {
      const file = event.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          restoreFromImport(data);
          showHelpBanner('Imported multi-channel session.');
        } catch (err) {
          console.error(err);
          showHelpBanner('Import failed. Invalid file.');
        }
      };
      reader.readAsText(file);
      event.target.value = '';
    }

    function restoreFromImport(data) {
      const snapshotOverlay = document.getElementById('snapshotOverlay');
      if (snapshotOverlay) snapshotOverlay.classList.remove('active');
      snapshotOverlayChannel = null;
      document.getElementById('channelScroller').innerHTML = '';
      appState.channels = [];
      channelMap.clear();
      (data.channels || []).forEach(cfg => {
        const channel = new Channel(cfg);
        channelMap.set(channel.id, channel);
        appState.channels.push(channel);
        mountChannel(channel);
        const numeric = parseInt((channel.symbolicId || '').replace(/[^0-9]/g, ''), 10);
        if (!Number.isNaN(numeric)) {
          channelSequence = Math.max(channelSequence, numeric + 1);
        }
      });
      appState.currentChannelId = appState.channels[0]?.id || null;
      if (data.theme) {
        applyTheme(data.theme);
      } else {
        applyTheme(appState.theme);
      }
      ringMemory.entries = [];
      ringMemory.mainline = null;
      ringMemory.contextMode = 'all';
      ringMemory.contextAnchor = null;
      ringEntryCounter = 1;
      if (data.ring) {
        const restoredEntries = (data.ring.entries || []).map(entry => ({
          ...entry,
          channelName: sanitizeHandle(entry.channelName || 'GLOBAL', 'GLOBAL'),
          symbol: sanitizeHandle(entry.symbol || entry.channelName || 'ENTRY', 'ENTRY'),
          type: sanitizeHandle(entry.type || 'NOTE', 'NOTE')
        }));
        ringMemory.entries = restoredEntries.slice(-ringMemory.capacity);
        ringMemory.mainline = data.ring.mainline || null;
        ringMemory.contextMode = data.ring.contextMode || 'all';
        ringMemory.contextAnchor = data.ring.contextAnchor
          || ringMemory.entries[ringMemory.entries.length - 1]?.id
          || null;
        const storedCounter = parseInt(data.ring.counter, 10);
        if (Number.isFinite(storedCounter) && storedCounter > ringEntryCounter) {
          ringEntryCounter = storedCounter;
        } else if (ringMemory.entries.length && !storedCounter) {
          const numeric = ringMemory.entries
            .map(entry => parseInt(String(entry.id).replace(/[^0-9]/g, ''), 10))
            .filter(Number.isFinite);
          if (numeric.length) {
            ringEntryCounter = Math.max(...numeric) + 1;
          }
        }
      }
      renderTimeline();
      renderRingBar();
      renderRingContext();
      syncRingContextButtons();
      persistState();
    }

    // Sound system
    let soundInitialized = false;
    let synth = null;

    async function initSound() {
      if (soundInitialized || typeof Tone === 'undefined') return;
      try {
        await Tone.start();
        synth = new Tone.Synth({
          oscillator: { type: 'sine' },
          envelope: { attack: 0.02, decay: 0.1, sustain: 0, release: 0.2 }
        }).toDestination();
        synth.volume.value = -24;
        soundInitialized = true;
      } catch (e) {
        console.warn('Sound init failed:', e);
      }
    }

    function playComposingTick() {
      if (!soundInitialized || !synth) return;
      try {
        synth.triggerAttackRelease('C5', '0.05');
      } catch (e) {
        console.warn('Sound play failed:', e);
      }
    }

    function playRevealChime() {
      if (!soundInitialized || !synth) return;
      try {
        synth.triggerAttackRelease('E5', '0.1');
        setTimeout(() => synth.triggerAttackRelease('G5', '0.1'), 100);
      } catch (e) {
        console.warn('Sound play failed:', e);
      }
    }

    document.addEventListener('click', async (event) => {
      if (!soundInitialized) await initSound();
      if (!event.target.closest('.message')) {
        closeAllMenus();
      }
    });

    window.addEventListener('beforeunload', persistState);

    document.addEventListener('DOMContentLoaded', initApp);
  </script>
</body>
</html>
